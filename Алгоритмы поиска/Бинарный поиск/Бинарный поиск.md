# Что такое бинарный поиск?

**Бинарный поиск** — это быстрый алгоритм для поиска первого вхождения элемента в **отсортированном массиве**.

## Как работает бинарный поиск

Представьте, что вы играете в игру "Угадай число" с другом. Каждый раз, когда вы называете число, друг отвечает:

* "Да, это загаданное число."
* "Нет, загаданное число меньше твоего."
* "Нет, загаданное число больше твоего."

Какая будет оптимальная стратегия для угадывания числа? Пусть можно загадывать числа от 1 до 100 включительно.

Друг загадал число. Вы называете "50". Друг говорит, что его число больше. Что это нам даёт? Все числа меньше или равные 50 исключаются — наш диапазон **уменьшился примерно вдвое**!

Теперь ищем в диапазоне от 51 до 100 включительно. Середина — 75. Вы говорите: "Это 75!". Друг отвечает: "Нет! Моё число меньше 75!". Опять мы **уменьшаем область поиска примерно вдвое**, теперь ищем от 51 до 74. Следующий кандидат — середина этого нового диапазона.

Логика ясна: каждый шаг мы находим середину текущего диапазона и в зависимости от ответа уменьшаем левую или правую границу поиска.

Именно так работает бинарный поиск. Его задача — определить, есть ли элемент в отсортированном массиве, а если есть — вернуть индекс этого элемента:

1. Находим **середину** массива.
2. Сравниваем искомый элемент (`target`) с элементом в середине (`arr[mid]`):

   * Если `target == arr[mid]` — элемент найден.
   * Если `target < arr[mid]` — ищем в **левой половине**.
   * Если `target > arr[mid]` — ищем в **правой половине**.
3. Повторяем, пока не найдём элемент либо пока диапазон поиска не станет пустым.

## Реализация на Python

```python
def binary_search(arr, target):
    left = 0  # левая граница поиска
    right = len(arr) - 1  # правая граница поиска
    
    while left <= right:
        mid = (left + right) // 2  # определяем середину диапазона
        if arr[mid] == target:  # элемент найден
            return mid
        elif arr[mid] < target:  # искомый элемент больше среднего
            left = mid + 1  # сдвигаем левую границу вправо
        else:  # искомый элемент меньше среднего
            right = mid - 1  # сдвигаем правую границу влево
    return -1  # элемент не найден
```

Важно помнить: **массив должен быть отсортирован!** Иначе алгоритм не работает корректно.

## Другие варианты бинарного поиска

**Левосторонний бинарный поиск** — находит первое вхождение искомого значения в массиве, если оно есть. Если значение повторяется, возвращает индекс первого из них.

```python
def left_binary_search(arr, target):
    left = 0
    right = len(arr) - 1
    result = -1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            result = mid  # нашли элемент, продолжаем поиск слева
            right = mid - 1
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return result
```

**Правосторонний бинарный поиск** — находит последнее вхождение искомого значения.

```python
def right_binary_search(arr, target):
    left = 0
    right = len(arr) - 1
    result = -1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            result = mid  # нашли элемент, продолжаем поиск справа
            left = mid + 1
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return result
```

Изменяется только одна строчка после `result = mid` — для левого поиска сдвигается правая граница, для правого — левая.

## Big O бинарного поиска

Бинарный поиск имеет **логарифмическую сложность** — **O(log n)**, что означает:

* На каждом шаге алгоритм **уменьшает зону поиска примерно вдвое**.
* Для массива из `n` элементов максимальное число шагов равно **log₂ n**.

Пример:

* Для 8 элементов: log₂ 8 = 3 шага.
* Для 1024 элементов: log₂ 1024 = 10 шагов.
* Для 1 миллиона элементов: log₂ 1,000,000 ≈ 20 шагов.

Это огромный выигрыш по сравнению с линейным поиском.

Если сравнить:

* Линейный поиск для числа 1024 — потенциально 1024 проверенных элемента (O(n)).
* Бинарный поиск — максимум 10 проверок (O(log n)).

## Где используется бинарный поиск?

* Поиск элементов в отсортированных массивах.
* Индексы в базах данных (например, SQL).
* Поиск в больших отсортированных файлах.
* Во многих алгоритмах и структурах данных для ускорения поиска.

## Заключение

**Бинарный поиск** — один из **самых эффективных** алгоритмов поиска с временной сложностью **O(log n)**. Он незаменим, когда нужен быстрый доступ к данным, но **только если данные отсортированы**.
