# Что такое бинарный поиск?

**Бинарный поиск** - это быстрый алгоритм для поиска первого вхождения элемента в **отсортированном массиве**.

## Как работает бинарный поиск
Представьте, что вы играете в игру "Угадай число" с другом. Каждый раз, когда вы будете говорить свою догадку, друг может ответить следующим образом:
- "Да, это загаданное число"
- "Нет, это число меньше твоего"
- Нет, это число больше твоего

Какая будет оптимальная стратегия для угадывания числа? Пусть можно загадывать числа от 1 до 100 включительно.

Вот друг загадал число. Давайте ответим "50". Друг говорит, что его число больше. Что же это нам дало? Все числа меньше 50, да и само 50 включительно, не подходят! Наши варианты ответа **уменьшились вдвое**!

Идем дальше. Теперь работаем с диапазон от 50 до 100 включительно. Серединой будет 75. Отвечаем: "Это 75!".
На что друг отвечает: "Нет! Мое число меньше 75!". И вот мы снова **вдвое уменьшили** варианты ответа! Надо искать от 50 до 75. А следующий нашим числом будет...

Думаю, к этому моменту логика понятна. Каждый раз мы искали середину, а затем в зависимости от ответа уменьшали левую или правую границу поиска.

По такой же схеме и работает бинарный поиск. Его задача - определять есть ли элемент в отсортированном массиве, либо же определять и возвращать индекс элемента в отсортированном массиве:
1. Находим **середину** массива.
2. Сравниваем искомый элемент (`target`) с элементом в середине:
    - Если `target == arr[mid]` → элемент найден.
    - Если `target < arr[mid]` → ищем в **левой половине**.
    - Если `target > arr[mid]` → ищем в **правой половине**.
3. Повторяем, пока не найдем элемент либо сократим поиск массива до нуля.

## Реализация на Python
```python
def binary_search(arr, target):
    left = 0 # левая граница поиска
    right = len(arr) - 1 # правая граница поиска
    
    while left <= right:
        mid = (left + right) // 2 #Определяем середину нашего диапазона
        if arr[mid] == target: # если элемент найден
            return mid
        elif arr[mid] < target: # если наш элемент по середине меньше заданного
            left = mid + 1 # то уменьшаем левую границу поиска
        else: # иначе если наш элемент по середине больше заданного
            right = mid - 1 # уменьшаем правую границу поиска
    return -1  # Элемент не найден
```

Важно запомнить, что массив должен быть отсортирован! Иначе весь алгоритм ломается.

## Другие варианты бинарного поиска

**Левосторонний бинарный поиск** – это вариант бинарного поиска, который находит первое вхождение искомого значения в массиве, если оно присутствует. Если искомое значение повторяется в массиве, левосторонний бинарный поиск вернет индекс первого вхождения этого значения.

```python
def left_binary_search(arr, target): 
	left = 0 
	right = len(arr) - 1 
	result = -1 
	while left <= right: 
		mid = left + (right - left) // 2 
		if arr[mid] == target: 
			result = mid # Нашли элемент, но не заканчиваем работу функции 
			right = mid - 1 # Смещаем правую границу, чтобы работать больше с левой половиной
		elif arr[mid] < target: 
			left = mid + 1 
		else: 
			right = mid - 1 
	return result
```

**Правосторонний бинарный поиск** – это вариант бинарного поиска, который находит последнее вхождение искомого значения в массиве, если оно присутствует. Если искомое значение повторяется в массиве, правосторонний бинарный поиск вернет индекс последнего вхождения этого значения.

```python
def left_binary_search(arr, target): 
	left = 0 
	right = len(arr) - 1 
	result = -1 
	while left <= right: 
		mid = left + (right - left) // 2 
		if arr[mid] == target: 
			result = mid # Нашли элемент, но не заканчиваем работу функции 
			left = mid + 1 # Смещаем левую половину, чтобы больше работать с правой
		elif arr[mid] < target: 
			left = mid + 1 
		else: 
			right = mid - 1 
	return result
```

Меняется лишь одна строчка после `result = mid`.
## Big O бинарного поиска
Бинарный поиск имеет **логарифмическую сложность** - \***O(log n)**, что означает:
- На каждом шаге алгоритм **уменьшает зону поиска вдвое**.
- Для массива из `n` элементов максимальное число шагов равно **log₂n**.

*\*Если удивляет запись O(log n), а не O(log₂n), то все дело в правилах упрощения нотации Big O.*

Так, если снова проводить аналогию с "Угадай число" и загадывать только самое крайнее (допустим из 1 до 100 загадать 1 или 100), то:
- Для 8 элементов: log₂8 = **3 шага**.
- Для 1024 элементов: log₂1024 = **10 шагов**.
- Для 1 млн элементов: log₂1,000,000 ≈ **20 шагов**.

Прирост во времени огромен! Сравните линейный поиск и бинарный поиск для числа 1024: используя линейный поиск мы бы называли последовательно числа от 1 до 1024, выполняю алгоритм за O(n). А с бинарным поиском мы бы назвали максимум 10 чисел! И все это за O(log n)!

## Где используется бинарный поиск?
- Поиск в массивах
- Индексы в SQL
- Поиск в больших отсортированных файлах

## Заключение
**Бинарный поиск** — один из **самых эффективных** алгоритмов поиска, работающий за **O(log n)**. Он незаменим в задачах, где требуется быстрый доступ к данным, но **только при условии, что данные отсортированы**.





