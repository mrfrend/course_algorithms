# Что такое стек?
**Стек** - это абстрактный тип данных, позволяющий работать с самым последним (верхним) добавленным элементом. Реализация стека должна предоставлять по крайне мере следующие две операции:
- push(e) - добавить элемент e в верх стека
- pop() - удалить самый верхний элемент стека

Несмотря на то, что стек - это АТД, а не структура данных, я решил включить его в этот модуль (как и очередь), потому что его можно реализовать при помощи и массива, и связного списка. Дальше будет задание на подумать над реализацией стека, используя для этого и массив и связный список.

## Как можно представить стек?
Представить стек и работу с ним можно в виде стопки бумаги. Когда вам необходим листок бумаги, вы берете его *сверху*, а стопка бумаги становится меньше.
Когда же бумага начинает заканчиваться, вы добавляете новые листки также *сверху*. 

Это основные две операции, являющиеся основой стека. Более совершенные разновидности стека могут поддерживать дополнительные операции: проверку наличия в стеке элементов или получения их количества.

Такая работа с данными известна под названием **LIFO** (Last-In, First-out, "последним пришёл, первым вышел"): мы можем удалить только верхний элемент, который был добавлен последним

## Примеры использования стека
Стек используется там, где важно обрабатывать элементы в **обратном порядке** их добавления.
- **Отмена действий (Undo)**. В текстовых редакторах (Ctrl+Z) последнее изменение удаляется первым.

- **Вызов функций (Call Stack)**. Программы используют стек для хранения адресов возврата и локальных переменных. При вызове функции она добавляется в стек, при завершении — удаляется. 
       
- **История браузера (Back/Forward)**. При переходе по страницам адреса сохраняются в стек. Кнопка **"Назад"** извлекает последнюю посещённую страницу.

## Реализация стека
Как было сказано выше, стек можно реализовать используя массивы или связные списки. Прежде чем начать, подумайте и сделайте реализацию сами, используя уже пройденные нами структуры данных. Как только вы сделали, либо же у вас возникли проблемы, можете сравнить с  моим вариантом реализации стека на Python.

### Реализация на массивах
В Python для реализация на массивах нам нет нужды придумывать нечто новое. Для этого уже есть тип данных `list` - список. Все, что надо делать, это работать с данными как со стопкой бумаги - **LIFO**.

```python
stack = []
stack.append(1)
stack.append(2)
stack.append(3)

print(stack)
print(stack.pop())
print(stack.pop())
print(stack.pop())
print(stack)
```

Либо же можем сделать отдельный класс для явного ограничения разрешимых операций:

```python
class Stack:
    def __init__(self, *args):
        self.__items = [*args]

    def push(self, item):
        self.__items.append(item)

    def pop(self):
        return self.__items.pop() if not self.is_empty() else "Стек пуст"

    def is_empty(self):
        return not self.__items

stack = Stack(1, 2, 3)
print(stack.pop()) # Удаляем 3
print(stack.pop()) # Удаляем 2
print(stack.pop()) # Удаляем 1
```

### Реализация на связных списках
За основу берем опять же узел. А реализовываем всего лишь несколько операций:

```python
class Node:
    def __init__(self, data):
        self.value = data
        self.next = None

class Stack:
    def __init__(self, *args):
        self.top = None  # Вершина стека
        for item in args: # Добавляем элементы в стек по порядку, если они переданы в конструкторе
            self.push(item)
            
    def push(self, data):
        new_node = Node(data)
        new_node.next = self.top  # Новый элемент ссылается на предыдущую вершину
        self.top = new_node  # Обновляем вершину стека

    def pop(self):
        if self.top is None:
            return None

        temp = self.top
        self.top = self.top.next  # Перемещаем вершину на следующий элемент
        return temp.value
```

## Big O стека

Стек, реализованный **на связном списке** (как в исправленном примере) или **на динамическом массиве**, имеет следующие временные сложности операций:

| Операция | Временная сложность (Big O) | Пояснение |
|----------|----------------------------|-----------|
| `push()` | **O(1)**  | Добавление элемента в вершину стека. |
| `pop()`  | **O(1)**                    | Удаление элемента из вершины. |
| `is_empty()` | **O(1)**              | Проверка на пустоту. |

При реализации на динамическом массиве операция `push()` может происходить за **O(n)** - случаи, когда массив заполнен, и необходимо найти новый кусок памяти (реаллокация, reallocation).

# Заключение
- **Стек — это АТД (LIFO)**, поддерживающий две основные операции:  
   - `push(e)` — добавление элемента в вершину.  
   - `pop()` — удаление верхнего элемента.  
- Вы можете представлять стек как стопку бумаги.
- Cтек используют для отмены последний действий, для реализации кнопки "Назад" в браузере
- Операции `push()`, `pop()`, `is_empty()` выполняются за  **O(1)**.  
- Для реализации стека на  динамическом массиве `push()` иногда выполняется за **O(n)** (при реаллокации), но в среднем **O(1)**.  
