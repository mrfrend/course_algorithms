# Что такое стек?

**Стек** — это абстрактный тип данных (АТД), работающий по принципу LIFO (Last-In, First-Out — "последним пришёл, первым вышел"). Основные операции стека:
- `push(e)` — добавить элемент `e` на вершину стека
- `pop()` — удалить и вернуть верхний элемент стека

## Принцип работы стека

Стек можно представить как стопку тарелок:
1. Новые элементы добавляются **только сверху** (операция `push`)
2. Элементы удаляются **только сверху** (операция `pop`)

![Стек](https://media.geeksforgeeks.org/wp-content/cdn-uploads/20230726165552/Stack-Data-Structure.png)

## Применение стеков

Стеки широко используются в программировании:

1. **Механизм отмены действий (Undo)**
   - Каждое действие сохраняется в стек
   - Ctrl+Z извлекает последнее действие

2. **Стек вызовов функций**
   - Хранит контекст выполнения функций
   - Обеспечивает правильный порядок возврата

3. **Парсеры и обработка выражений**
   - Проверка баланса скобок
   - Перевод выражений между форматами (инфиксная → постфиксная запись)

4. **История браузера**
   - Кнопка "Назад" использует стек посещённых страниц

## Реализация стека

### 1. Реализация на массиве (Python list)
```python
class ArrayStack:
    def __init__(self):
        self.__items = []

    def push(self, item):
        """Добавление элемента на вершину стека"""
        self.__items.append(item)  # O(1)*

    def pop(self):
        """Удаление и возврат верхнего элемента"""
        if self.is_empty():
            raise IndexError("Стек пуст")
        return self.__items.pop()  # O(1)

    def is_empty(self):
        """Проверка на пустоту"""
        return len(self.__items) == 0  # O(1)

    def peek(self):
        """Просмотр верхнего элемента без удаления"""
        if self.is_empty():
            raise IndexError("Стек пуст")
        return self.__items[-1]  # O(1)
```

* — амортизированная сложность (при переполнении массива O(n))

### 2. Реализация на связном списке
```python
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

class LinkedStack:
    def __init__(self):
        self.top = None  # Вершина стека

    def push(self, value):
        """Добавление элемента на вершину"""
        new_node = Node(value)
        new_node.next = self.top  # Новый элемент ссылается на текущую вершину
        self.top = new_node       # Обновляем вершину

    def pop(self):
        """Удаление и возврат верхнего элемента"""
        if self.top is None:
            raise IndexError("Стек пуст")
        value = self.top.value
        self.top = self.top.next  # Перемещаем вершину
        return value

    def is_empty(self):
        """Проверка на пустоту"""
        return self.top is None

    def peek(self):
        """Просмотр верхнего элемента"""
        if self.top is None:
            raise IndexError("Стек пуст")
        return self.top.value
```

## Сравнение реализаций

| Характеристика       | Массив (list) | Связный список |
|----------------------|---------------|----------------|
| **push()**           | O(1)*         | O(1)           |
| **pop()**            | O(1)          | O(1)           |
| **peek()**           | O(1)          | O(1)           |
| **Память**           | Меньше        | Больше         |
| **Локализация данных**| Лучше        | Хуже           |

* — амортизированная сложность

## Временная сложность операций

| Операция  | Сложность | Примечание |
|-----------|-----------|------------|
| push()    | O(1)      | Добавление в конец (для массива — O(1) амортизированно) |
| pop()     | O(1)      | Удаление из конца |
| peek()    | O(1)      | Доступ к последнему элементу |
| is_empty()| O(1)      | Проверка на пустоту |

## Когда использовать стек?

**Идеальные сценарии:**
- Обработка в обратном порядке
- Алгоритмы с рекурсивной природой
- Задачи, требующие отмены/повтора действий
- Синтаксический анализ (парсинг)

**Преимущества:**
- Простая и эффективная структура
- Быстрые основные операции
- Естественная модель для многих алгоритмов

**Ограничения:**
- Доступ только к верхнему элементу
- Не подходит для задач, требующих произвольного доступа

## Заключение

Стек — это фундаментальная структура данных, которая:
1. Работает по принципу LIFO
2. Поддерживает две ключевые операции (push/pop)
3. Имеет O(1) для основных операций
4. Широко применяется в системном программировании и алгоритмах

Понимание стека критически важно для освоения более сложных структур данных и алгоритмов.