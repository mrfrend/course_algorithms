# Что такое очередь?

**Очередь** — это абстрактный тип данных, работающий с элементами в порядке их поступления. Основные операции очереди:
- **enqueue(e)** — добавить элемент `e` в конец очереди
- **dequeue()** — извлечь элемент из начала очереди

**Очередь является противоположностью стека** по принципу организации данных.

## Принцип работы очереди

Очередь работает по принципу **FIFO** (First-In, First-Out — "первым пришёл, первым вышел"). Это означает, что первый добавленный элемент будет первым извлечённым.

Аналогия: очередь в магазине — первый вставший в очередь покупатель будет первым обслужен.

## Применение очередей

Очереди используются, когда важен **порядок обработки элементов**:
1. **Планирование задач** — операционные системы управляют процессами с помощью очередей
2. **Обработка запросов** — веб-серверы обрабатывают HTTP-запросы в порядке поступления
3. **Поиск в ширину (BFS)** — алгоритм обхода графов, использующий очередь
4. **Буферизация ввода** — обработка нажатий клавиш в порядке их поступления

## Реализация очереди

### 1. Реализация на массиве
```python
class Queue:
    def __init__(self):
        self.__items = []

    def enqueue(self, item):
        """Добавляет элемент в конец очереди"""
        self.__items.append(item)  # O(1)
        
    def dequeue(self):
        """Извлекает элемент из начала очереди"""
        if self.is_empty():
            return None
        return self.__items.pop(0)  # O(n) - медленно из-за сдвига элементов
        
    def is_empty(self):
        return not self.__items
```

**Недостатки:**
- Операция `dequeue()` имеет сложность O(n) из-за необходимости сдвигать элементы
- При использовании динамического массива возможны затратные операции реаллокации памяти

### 2. Реализация на связном списке (оптимальная)
```python
class Node:
    def __init__(self, data):
        self.value = data
        self.next = None

class Queue:
    def __init__(self):
        self.head = None  # Первый элемент
        self.tail = None  # Последний элемент

    def enqueue(self, item):
        """Добавление в конец очереди"""
        new_node = Node(item)
        if self.tail is None:  # Если очередь пуста
            self.head = new_node
            self.tail = new_node
        else:
            self.tail.next = new_node
            self.tail = new_node

    def deque(self):
        """Извлечение из начала очереди"""
        if self.head is None:
            return None
        temp = self.head
        self.head = temp.next
        if self.head is None:
            self.tail = None  # Очередь опустела
        return temp.value

    def is_empty(self):
        return self.head is None
```

**Преимущества:**
- Все операции выполняются за O(1)
- Динамическое выделение памяти
- Нет необходимости сдвигать элементы

### 3. Использование deque из модуля collections
```python
from collections import deque

queue = deque()
queue.append(1)    # Добавление в конец
queue.popleft()    # Извлечение из начала
```

**Особенности:**
- Реализована как двусторонняя очередь
- Все операции выполняются за O(1)
- Оптимизированная реализация на C

## Сравнение сложности операций

| Операция      | Массив | Связный список | deque |
|--------------|--------|----------------|-------|
| enqueue()    | O(1)*  | O(1)           | O(1)  |
| dequeue()    | O(n)   | O(1)           | O(1)  |
| is_empty()   | O(1)   | O(1)           | O(1)  |

* — амортизированная сложность для динамического массива

## Заключение
1. Очередь работает по принципу FIFO (первым пришёл — первым вышел)
2. Основные операции: enqueue() и dequeue()
3. Оптимальная реализация — на связном списке или с использованием deque
4. Очереди широко применяются в системном программировании и алгоритмах