# Что такое очередь?

**Очередь** — абстрактный тип данных, позволяющий обрабатывать элементы в порядке их поступления. Она поддерживает как минимум две основные операции:

* `enqueue(e)` — добавить элемент `e` в конец очереди
* `dequeue()` — удалить элемент из начала очереди

**Очередь — полная противоположность стеку.**

---

## Как можно представить очередь?

Очередь — это буквально... очередь. Например, очередь в магазине или за заказом в кафе: всех обслуживают в порядке прибытия.

Очереди реализуют принцип **FIFO** (First-In, First-Out — "первым пришёл, первым вышел"): элемент, добавленный первым, удаляется первым.

---

## Примеры использования очереди

Очереди полезны там, где важен **порядок обработки** элементов:

* **Планирование задач (Task Scheduling)** — операционные системы используют очереди для управления процессами
* **Обработка запросов (Message Queues)** — веб-серверы обрабатывают HTTP-запросы в порядке поступления
* **Поиск в ширину (BFS)** — используется очередь для обхода графа по уровням
* **Буфер ввода (Input Buffering)** — ввод с клавиатуры обрабатывается в порядке нажатия клавиш

---

## Реализация очереди

Очередь можно реализовать с помощью **массива** или **связного списка**, как и стек.

---

### Реализация на массиве

```python
class Queue:
    def __init__(self):
        self.__items = []

    def enqueue(self, item):
        """Добавляет элемент в конец очереди."""
        self.__items.append(item)
        
    def dequeue(self):
        """Удаляет и возвращает первый элемент очереди."""
        if self.is_empty():
            return None
        return self.__items.pop(0)  # O(n) — медленно из-за сдвига элементов
        
    def is_empty(self):
        return not self.__items
```

Хотя динамический массив позволяет быстро добавлять элементы в конец (`O(1)` *в среднем*), операция `dequeue()` (`pop(0)`) выполняется за `O(n)`, поскольку все элементы сдвигаются влево.

---

### Реализация на связном списке

Связный список — более подходящий вариант: память выделяется динамически, а вставка и удаление из начала/конца происходят быстро.

```python
class Node:
    def __init__(self, data):
        self.value = data
        self.next = None

class Queue:
    def __init__(self):
        self.head = None  # Первый элемент (голова)
        self.tail = None  # Последний элемент (хвост)

    def enqueue(self, item):
        new_node = Node(item)
        if self.tail is None:  # очередь пуста
            self.head = new_node
            self.tail = new_node
        else:  # добавление в конец
            self.tail.next = new_node
            self.tail = new_node

    def dequeue(self):
        if self.head is None:
            return None
        temp = self.head
        self.head = temp.next
        if self.head is None:
            self.tail = None  # очередь опустела
        return temp.value

    def is_empty(self):
        return self.head is None
```

Операции `enqueue()` и `dequeue()` выполняются за `O(1)`, так как используются указатели на начало и конец.

---

### Использование `deque` в Python

**Deque** (двусторонняя очередь) — структура данных, позволяющая добавлять и удалять элементы с **обоих концов** за `O(1)`.

```python
from collections import deque
storage = deque()
```

Deque можно использовать для реализации очереди (FIFO).

| Операция        | Описание                                | Сложность |
| --------------- | --------------------------------------- | --------- |
| `append(x)`     | Добавить `x` в **конец**                | `O(1)`    |
| `appendleft(x)` | Добавить `x` в **начало**               | `O(1)`    |
| `pop()`         | Удалить и вернуть **последний** элемент | `O(1)`    |
| `popleft()`     | Удалить и вернуть **первый** элемент    | `O(1)`    |

---

## Сравнение производительности

| Метод        | Массив (`list`)         | Связный список |
| ------------ | ----------------------- | -------------- |
| `enqueue()`  | `O(1)*` (иногда `O(n)`) | `O(1)`         |
| `dequeue()`  | `O(n)`                  | `O(1)`         |
| `is_empty()` | `O(1)`                  | `O(1)`         |

\* амортизированная сложность при использовании динамического массива

---

## Заключение

* Очередь реализует принцип **FIFO**: первым пришёл — первым обслужен
* Применяется в системах, где важен порядок обработки данных
* **Связный список** обеспечивает эффективные операции добавления и удаления — всё за `O(1)`
* **Deque** из `collections` — удобная и быстрая реализация очереди в Python

