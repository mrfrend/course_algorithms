# Что такое очередь?
**Очередь** - абстрактный тип данных, позволяющий работать с данными в порядке их поступления. Реализация очереди предполагает как минимум две следующих операции:
- **enqueue(e)** - добавить элемент `e` в конец очереди.
- **dequeue()** - удалить элемент из начала очереди.

**Очередь - полная противоположность стеку.**

## Как можно представить очередь?
Очередь можно представить как... очередь. Да, такая тавтология. Очередь за продуктами, очередь за заказом. Всех обслуживают в порядке прибытия в очереди.

Здесь мы работаем по принципу организации данных **FIFO** (First-In, First-Out, "первым пришел, первым вышел"), потому что первый помещенный элемент в очередь всегда выходит из нее первый.

## Примеры использования очереди
Очередь используется, когда важен **порядок поступления элементов**.  
- **Планирование задач (Task Scheduling)**. Операционная система использует очереди для управления процессами.
- **Обработка запросов (Message Queues)**. Веб-серверы обрабатывают HTTP-запросы в порядке их поступления.  
- **BFS (поиск в ширину в графах)**. Алгоритм посещает узлы уровня за уровнем, используя очередь.  Это мы разберем дальше.
- **Буфер ввода (Input Buffering)**. Клавиатурный ввод обрабатывается в порядке нажатия клавиш.  

## Реализация очереди
Очередь можно реализовать, используя массив либо связный список. Прямо как и стек.

### Реализация на массиве
```python
class Queue:
    def __init__(self):
        self.__items = []

    def enqueue(self, item):
        """Добавляет элемент в конец очереди."""
        self.__items.append(item)
        
    def dequeue(self):
        """Удаляет и возвращает первый элемент очереди."""
        if self.is_empty():
            return None
        return self.__items.pop(0)  # O(n) - медленно из-за сдвига элементов
        
    def is_empty(self):
        return not self.__items
```

Однако это не идеальный вариант. Мы редко знаем сколько элементов будем мы хранить, в таком случае необходимо использовать динамический массив. Динамический массив хоть и хорошо работает с добавлением в конец, за **O(1)**, делает он это не всегда. Не стоит забывать про реаллокацию памяти, которая занимает **O(1)**.

Операция `dequeue()` будет всегда занимать **O(n)**, что очень медленно. Подробнее почему объяснено в уроке про массивы.

### Реализация на связном списке
Считается идеальным вариантом: простое динамическое выделение памяти, простота добавления/удаления из начала и конца.

```python
class Node:
    def __init__(self, data):
        self.value = data
        self.next = None

class Queue:
    def __init__(self):
        self.head = None  # Первый элемент (голова)
        self.tail = None  # Последний элемент (хвост)

    def enqueue(self, item):
        new_node = Node(item)
        if self.tail is None: # если же очередь пуста
            self.head = new_node
            self.tail = new_node
        else: # иначе меняем наш хвост
            self.tail.next = new_node
            self.tail = new_node

    def dequeue(self):
        if self.head is None:
            return None
        temp = self.head
        self.head = temp.next
      
        if self.head is None:
            self.tail = None  # Очередь опустела
        return temp.value

    def is_empty(self):
        return self.head is None

```

Добавление в очередь (`enqueue()`), извлечение из очереди (`dequeue()`) происходит за **O(1)** благодаря хранению первого и последнего элементов.

### deque
**Deque** (дек) — это структура данных, которая позволяет **добавлять и удалять элементы с обоих концов** (головы и хвоста) за **O(1)**.  
Она сочетает возможности **стека** (LIFO) и **очереди** (FIFO).

В Python есть встроенная реализация деки. Ее можно получить из модуля `collections`

```python
from collections import deque
storage = deque()
```

Как раз таки её можно использовать для работы с данными по принципу **FIFO**. Вот операции, которые поддерживает реализация deque в Python:

| Операция       | Описание                              | Сложность |
|----------------|---------------------------------------|-----------|
| `append(x)`    | Добавить `x` в **конец** дека         | **O(1)**  |
| `appendleft(x)`| Добавить `x` в **начало** дека        | **O(1)**  |
| `pop()`        | Удалить и вернуть **последний** элемент | **O(1)**  |
| `popleft()`    | Удалить и вернуть **первый** элемент  | **O(1)** 

## Big O очереди
| Метод         | Массив (`list`)| Связный список  |
|---------------|----------------|-----------------|
| `enqueue()`   | O(1)* (O(n))   |  O(1)           |
| `dequeue()`   | O(n)           |  O(1)           |
| `is_empty()`  | O(1)           |  O(1)           |

# Заключение
- Данные обрабатываются в порядке поступления (**FIFO** — First In, First Out).  
 - Аналогия: очередь в магазине (первый пришел — первый обслужен).  
- Очередь используют, когда важен порядок поступления элементов
- Очередь на связных списков реализует основные операции за **O(1)**