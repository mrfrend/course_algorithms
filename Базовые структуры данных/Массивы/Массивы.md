# Что такое массив?

**Массив** — это структура данных, представляющая собой непрерывную область памяти, в которой хранятся элементы одного типа в определённом порядке.

```python
names = ['Ivan', 'Peter', 'Adam']  # массив строк
numbers = [2, 4, 6, 8]             # массив целых чисел
```

---

## Доступ к элементам массива

Для обращения к элементу массива используется **индекс** — номер позиции в массиве. В большинстве языков программирования индексация начинается с **нуля**.

```python
names[0]     # 'Ivan' — первый элемент
numbers[3]   # 8 — четвёртый элемент
```

**Важно:** последний индекс массива равен `длина массива - 1`.

---

## Виды массивов

### 1. **Статические массивы**

Массивы фиксированного размера. Их длину нельзя изменить после создания.

```c
int numbers[5] = {};  // массив из 5 целых чисел
```

* Размер задаётся при создании
* Невозможно добавить элементы сверх установленного размера

---

### 2. **Динамические массивы**

Массивы, способные изменять свой размер во время выполнения программы. При добавлении элементов, когда не хватает места:

* Выделяется новая память (обычно в 2 раза больше)
* Все элементы копируются в новую область
* Старая память освобождается

В Python списки (`list`) реализованы как динамические массивы:

```python
import sys

names = ["Alice", "Bob", "Charlie"]
print(sys.getsizeof(names))  # Размер в байтах

names.extend(["Dana", "Eve"])  # Добавление элементов
print(sys.getsizeof(names))    # Размер мог увеличиться
```

**Почему размер увеличивают вдвое?**
Операция расширения требует `O(n)` времени. Увеличение размера вдвое позволяет достичь **амортизированной** сложности `O(1)` для добавлений.

---

### 3. **Универсальные массивы**

Массивы, способные хранить значения разных типов. В Python это обычные списки:

```python
mixed = ["text", 42, 3.14, True]
```

На самом деле хранятся **ссылки** на объекты. Все элементы занимают одинаковое место в массиве (размер указателя), что позволяет поддерживать разные типы.

---

## Основные операции и их сложность (Big O)

| Операция             | Сложность | Комментарий                |
| -------------------- | --------- | -------------------------- |
| Доступ по индексу    | `O(1)`    | Прямой доступ по адресу    |
| Поиск элемента       | `O(n)`    | Линейный перебор           |
| Вставка в конец      | `O(1)*`   | Амортизированная сложность |
| Вставка в начало     | `O(n)`    | Требуется сдвиг            |
| Вставка в середину   | `O(n)`    | То же самое                |
| Удаление из конца    | `O(1)`    | Просто уменьшается размер  |
| Удаление из начала   | `O(n)`    | Сдвигаются элементы        |
| Удаление из середины | `O(n)`    | Сдвиг аналогично           |

\* Амортизированная `O(1)` достигается за счёт увеличения буфера.

---

### Почему доступ по индексу — O(1)?

Память в массиве организована **непрерывно**, и все элементы имеют **одинаковый размер**.
Формула вычисления адреса:
`Адрес = Начальный адрес + (Индекс × Размер элемента)`

**Пример:**

Массив `arr = [10, 20, 30, 40]`, начинается с адреса `1000`, `int` = 4 байта:

* `arr[0]` → `1000 + 0×4 = 1000`
* `arr[2]` → `1000 + 2×4 = 1008`

---

## Вставка элементов

Если есть свободное место — вставка в конец выполняется мгновенно.
Если места нет:

* Выделяется новая память
* Все элементы копируются

**Амортизированная `O(1)`** означает, что большинство операций быстрые, а редкие "дорогие" операции (копирование) усредняются.

---

## Вставка в начало или середину

Вставка требует сдвига всех элементов справа от позиции.
**Сложность — `O(n)`**

Вставим `50` на позицию `1` в `[10, 20, 30, 40]`:

1. Сдвигаем: `[10, _, 20, 30, 40]`
2. Вставляем: `[10, 50, 20, 30, 40]`

---

## Удаление элементов

### Из конца — `O(1)`

* Просто уменьшается логическая длина массива
* Пример: удаление `40` из `[10, 20, 30, 40]` → `[10, 20, 30]`

### Из начала или середины — `O(n)`

* Все элементы после удалённого **сдвигаются влево**

**Пример:**
Удалим `20` из `[10, 20, 30, 40]`:

1. Удаление: `[10, _, 30, 40]`
2. Сдвиг: `[10, 30, 40]`

---

## Особенности массивов

* Быстрый доступ по индексу — `O(1)`
* Статические массивы имеют фиксированный размер
* Вставка/удаление в середину — дорогие операции (`O(n)`)
* При расширении — все элементы копируются в новую память

---

## Когда использовать массивы?

**Подходят, если:**

* Нужен быстрый доступ по индексу
* Часто происходит последовательный обход
* Размер данных стабилен

**Не подходят, если:**

* Часто вставляешь/удаляешь в начало или середину
* Размер данных сильно меняется → лучше использовать **связные списки**
