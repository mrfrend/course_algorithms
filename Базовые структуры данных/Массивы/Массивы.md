# Что такое массив?

**Массив** — это структура данных, представляющая собой непрерывную последовательность памяти, которая хранит совокупность элементов одного типа в определённом порядке.

```python
names = ['Ivan', 'Peter', 'Adam']  # массив строк
numbers = [2, 4, 6, 8]  # массив целых чисел
```

## Доступ к элементам массива

Для обращения к элементу массива используется **индекс** — номер позиции в массиве. В большинстве языков программирования индексация начинается с **нуля**.

```python
names[0]  # 'Ivan' (первый элемент)
numbers[3]  # 8 (четвёртый элемент)
```

**Важно:** последний индекс массива = количество элементов массива - 1.

## Виды массивов

### 1. Статические массивы
Массивы фиксированного размера. Их размер нельзя изменить после создания.

```c
int numbers[5] = {};  // Массив из 5 целых чисел
```

- Размер определяется при создании
- Нельзя добавить элементы сверх заданного размера

### 2. Динамические массивы
Массивы, которые могут изменять свой размер во время выполнения программы.
При добавлении элементов и нехватке места:
- Выделяется новый блок памяти (обычно в 2 раза больше текущего)
- Все элементы копируются в новую область памяти
- Старая память освобождается

В Python списки (`list`) — это динамические массивы:

```python
import sys

names = ["Alice", "Bob", "Charlie"]
print(sys.getsizeof(names))  # Размер в байтах

names.extend(["Dana", "Eve"])  # Добавляем элементы
print(sys.getsizeof(names))  # Размер мог увеличиться
```

**Почему увеличивают вдвое?**  
Операция расширения требует O(n) времени (на копирование). Увеличение вдвое позволяет достичь **амортизированной** сложности O(1) для операции добавления.

### 3. Универсальные массивы
Массивы, которые могут хранить элементы разных типов. В Python это обычные списки:

```python
mixed = ["text", 42, 3.14, True]
```

На самом деле хранятся не сами объекты, а **ссылки** (указатели) на них. Каждый элемент занимает одинаковый размер (размер указателя), что позволяет хранить разные типы.

## Основные операции и их сложность (Big O)

| Операция             | Сложность | Объяснение |
|----------------------|-----------|------------|
| Доступ по индексу    | O(1)      | Прямой доступ по адресу |
| Поиск элемента       | O(n)      | Нужно проверить все элементы |
| Вставка в конец      | O(1)*     | Амортизированная сложность |
| Вставка в начало     | O(n)      | Требуется сдвиг всех элементов |
| Вставка в середину   | O(n)      | Требуется сдвиг элементов |
| Удаление из конца    | O(1)      | Просто уменьшаем размер |
| Удаление из начала   | O(n)      | Требуется сдвиг элементов |
| Удаление из середины | O(n)      | Требуется сдвиг элементов |

*Примечание: Вставка в конец имеет O(1) амортизированную сложность благодаря стратегии увеличения размера (обычно в 2 раза).

### Доступ к элементу по индексу
**Почему O(1)?**  
Массив — это **непрерывная область памяти**, где каждый элемент имеет **фиксированный размер** (например, `int` занимает 4 байта).  

**Как это работает:**  
- Адрес элемента вычисляется по формуле: **Адрес = Начальный адрес + (Индекс × Размер элемента)**

Допустим, массив `arr = [10, 20, 30, 40]` начинается с адреса `1000`, а каждый `int` занимает 4 байта.  
  - `arr[0]` → `1000 + (0 × 4) = 1000`  
  - `arr[2]` → `1000 + (2 × 4) = 1008`  

### Вставка элемента
**Как работает:**  
- Если в массиве есть свободное место, элемент просто добавляется в конец.  
- Если места нет, массив **расширяется** (обычно в 2 раза), и все элементы копируются в новую область памяти.  

**Почему амортизированная O(1)?**  
- Большинство добавлений — O(1).  
- Редкие копирования при расширении — O(n), но их влияние "усредняется" до O(1).  

### Вставка в начало/середину (O(n))
**Почему O(n)?**  
При вставке элемента на позицию `i` все последующие элементы (`i, i+1, ...`) **сдвигаются вправо**.  

**Пример:**  
Добавим `50` на позицию `1` в `[10, 20, 30, 40]`: 

1. Сдвигаем `20, 30, 40` вправо: `[10, _, 20, 30, 40]` 
2. Вставляем `50`: `[10, 50, 20, 30, 40]`

**Чем больше массив, тем больше элементов нужно сдвинуть → O(n).**  

### Удаление элемента

**Удаление из конца (O(1))**
- Просто уменьшаем "логический" размер массива (в статических массивах) или удаляем последний элемент (в динамических).  
- **Пример:**  
  Удаляем `40` из `[10, 20, 30, 40]` → `[10, 20, 30]` (ничего не сдвигается).  

**Удаление из начала/середины (O(n))**   
При удалении элемента с позиции `i` все последующие элементы (`i+1, i+2, ...`) **сдвигаются влево**.  

**Пример:**  
Удалим `20` из `[10, 20, 30, 40]`:  
1. Удаляем `20`: `[10, _, 30, 40]`
2. Сдвигаем `30, 40` влево: `[10, 30, 40]`

**Чем больше массив, тем больше элементов нужно сдвинуть → O(n).**  

## Особенности массивов
- Молниеносный доступ к элементам по индексу (O(1))
- Фиксированный размер у статических массивов
- Дорогостоящие вставки/удаления в начало/середину (O(n))
- Необходимость копирования при расширении динамических массивов

## Когда использовать массивы?
**Используйте массивы, когда:**
- Нужен быстрый доступ к элементам по индексу
- Часто перебираете элементы последовательно
- Размер данных относительно постоянен

**Избегайте массивов, когда:**
- Часто вставляете/удаляете элементы из начала/середины
- Размер данных сильно меняется (рассмотрите связные списки)