# Что такое хеш-таблица?

**Хеш-таблица** — это структура данных, которая хранит пары "ключ-значение" и обеспечивает эффективный доступ к данным по ключу. В среднем случае операции с хеш-таблицей выполняются за O(1).

## Основные принципы работы

### 1. Структура хеш-таблицы
Хеш-таблица состоит из:
- **Массива** (основное хранилище)
- **Хеш-функции** (преобразует ключ в индекс массива)
- **Механизма разрешения коллизий** (обычно цепочки)

### 2. Хеш-функция
Ключевые свойства хорошей хеш-функции:
1. **Детерминированность** — одинаковые ключи дают одинаковый хеш
2. **Равномерность** — равномерно распределяет ключи по массиву
3. **Быстрота вычисления** — минимальные вычислительные затраты

Пример простой хеш-функции для строк:
```python
def hash_function(key, size):
    return sum(ord(char) for char in key) % size
```

### 3. Разрешение коллизий
Основные методы:
1. **Метод цепочек** (связные списки в каждой ячейке)
2. **Открытая адресация** (поиск следующей свободной ячейки)

## Реализация в Python

### Базовый вариант с цепочками
```python
class HashTable:
    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(size)]  # Массив списков

    def _hash(self, key):
        return hash(key) % self.size  # Встроенная хеш-функция Python

    def put(self, key, value):
        hash_key = self._hash(key)
        bucket = self.table[hash_key]
        
        # Проверка на существующий ключ
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)  # Обновление
                return
        bucket.append((key, value))  # Добавление нового

    def get(self, key):
        hash_key = self._hash(key)
        bucket = self.table[hash_key]
        
        for k, v in bucket:
            if k == key:
                return v
        raise KeyError(key)

    def delete(self, key):
        hash_key = self._hash(key)
        bucket = self.table[hash_key]
        
        for i, (k, v) in enumerate(bucket):
            if k == key:
                del bucket[i]
                return
        raise KeyError(key)
```

## Оптимизация производительности

### Коэффициент заполнения
Важно поддерживать баланс между размером таблицы и количеством элементов. При достижении коэффициента заполнения > 0.7 рекомендуется:

1. Увеличить размер таблицы (обычно в 2 раза)
2. Перехешировать все существующие элементы

```python
def resize(self, new_size):
    old_table = self.table
    self.size = new_size
    self.table = [[] for _ in range(new_size)]
    
    for bucket in old_table:
        for key, value in bucket:
            self.put(key, value)
```

## Встроенные реализации в Python

### Словарь (dict)
```python
phone_book = {
    "Alice": "123-4567",
    "Bob": "890-1234"
}

# Операции
phone_book["Charlie"] = "567-8901"  # Добавление
del phone_book["Bob"]  # Удаление
number = phone_book.get("Alice")  # Поиск
```

### Множество (set)
```python
unique_names = {"Alice", "Bob", "Charlie"}
unique_names.add("David")  # Добавление
unique_names.remove("Bob")  # Удаление
```

## Сложность операций

| Операция       | Средний случай | Худший случай |
|----------------|----------------|---------------|
| Вставка        | O(1)           | O(n)          |
| Поиск         | O(1)           | O(n)          |
| Удаление      | O(1)           | O(n)          |

*Худший случай возникает при плохой хеш-функции или высокой нагрузке*

## Применение хеш-таблиц

1. **Кэширование** (memcached, Redis)
2. **Индексация данных** (базы данных)
3. **Подсчет частот** (анализ текста)
4. **Удаление дубликатов** (множества)
5. **Оптимизация поиска** (замена линейного поиска)

## Заключение

Хеш-таблицы — это мощный инструмент для:
- Эффективного хранения пар "ключ-значение"
- Быстрого доступа к данным (в среднем O(1))
- Решения широкого круга задач программирования

Понимание работы хеш-таблиц помогает выбирать оптимальные структуры данных и писать более эффективный код.