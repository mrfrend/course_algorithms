# Что такое хэш-таблица?

**Хэш-таблица** - это структура данных, позволяющая хранить данные в парах **ключ-значения.** Мы можем получать значение в памяти по заданному ключ.

Хэш-таблица является популярной структурой данных, позволяющая получать, записывать и удалять элемента в среднем за O(1).

## Как можно представить хэш-таблицу?
Распространенным примером представления хэш-таблицы является телефонная книга. В телефонной книге у вас два столбца: данные об человека (для простоты просто имя и фамилия), а также его номер телефона.

Здесь ключом является комбинация фамилии и имени человека, а значением его номер телефона.

В целом это и есть идея хэш-таблицы: по понятному нам ключу (чаще всего строки) получать соответствующие данные.

## Примеры использования хэш-таблицы
Хэш-таблицу используют для:
- Моделирования отношений между объектами (человек - номер телефона)
- Удаление дубликатов
- Кэширования

Также на основе хэш-таблицы реализуют некоторые АТД как множество (set), ассоциативный массив (словарь, dict)

## Как работает хэш-таблица?
На самом деле, хэш-таблица очень похожа на массив. **Она использует массив как одну из своих ключевых частей**.
Надеюсь, вы помните, что достоинством массива является быстрый доступ к его элементам за O(1). Однако в массиве для обозначения позиции используется индекс. А мы хотим в качестве ключа использовать не только числа, но и другие типы данных: строки, кортежи - все неизменяемые типы данных, в общем. 

Как же подружить идею получения данных по ключу с массивом? Да и почему ключом может быть только неизменяемый тип данных? На данные вопросы нам ответит ***хэш-функция***. 

### Хэш-функция

**Хэш-функция** - это функция, которая принимает на вход ключ, а возвращает индекс - позицию в массиве. Вот и все чудеса.

Чтобы начать работу с ключом, его пропускают через хэш-функцию и получают индекс. А затем с этим индексом мы можем совершить необходимую нам операцию: перезаписать значение ключа, добавить значение ключа, удалить значение ключа.

Хэш-функция должна соответствовать одному требованию: она должна быть **детерминированной**.

Детерминированность означает, что **функция для одних и тех же входных значений всегда возвращает  один и тот же результат**, без исключений.
Иными словами, для одного и того же ключа она должна возвращать то же число.
К примеру, если вызов хэш-функции с ключом "Алгоритм" возвращает число 3, то последующие вызовы функции с тем же ключом должны возвращать также 3.

Теперь вы знаете ответ на первый вопрос. Что насчет второго?

Давайте проведем мысленный эксперимент. Пусть наша хэш-функция может принимать в качестве ключа списки - изменяемый тип данных.

Формула работы нашей хэш-функции для массива будет такая:
1. Рассчитать произведение элемента массива с его индексом
2. Вычислить сумму произведений
3. Поделить с остатком сумму произведений на длину хэш-таблицы (массива)

3 шаг нужен, чтобы наш индекс был в пределах работы массива. Будем считать, что для массива выделено памяти на 10 элементов.

Возьмем в качестве ключа массив `[1,2,3]`, его значением будет 10.
```python
#Псевдокод
key = [1, 2, 3]
hash_table[key] = 10
print hash_table[key] # 10
```

Кстати, для нашего ключа будет вычислен индекс 0.

А теперь добавим еще один элемент нашему ключу (массиву):
```python
# Псевдокод
key.push(4)
```

К этому моменту вы могли понять в чем будет проблема. Если нет, ничего страшного.
Если же теперь высчитать хэш для данного ключа, получится 2 (сумма произведений 22 % 10 = 2). Но ведь данные хранятся в нулевой ячейке!

**Хэш-функция запрещает** использовать в качестве ключа изменяемые типы данных **из-за возможности изменения хэша ключа.**

### Коллизия
Может возникнуть вопрос: *"А можно ли для разных ключей получить одинаковые числа?"*. Да, такое возможно.

**Коллизия** - это ситуация, когда разные ключи дают одинаковый хэш, и, следовательно, претендуют на одну и ту же ячейку в хэш-таблице.

Раз они претендуют на одну и ту же ячейку, мы можем сами того не подозревая перезаписать существующие данные.

**Как же решают коллизии? С помощью связного списка**. Теперь при обнаружении, что в ячейке уже есть значение для некоторого ключа, мы будем хранить в этой ячейке указатель на начало связного списка. В конец связного списка будем добавлять новую пару ключ-значение. 

**Хэш-таблица - это массив связных списков.**

Таким образом, в одной ячейке у нас будут храниться несколько значений. Только поиск в этом случае станет медленнее, в худшем случае за \*O(n), где n - это количество ключей - в хэш-таблице


\*Пояснение: здесь как всегда подразумевается самый худший случай. В нашем случае когда плохая хэш-функция для любого ключа выдаёт один и тот хэш, из-за чего все элементы хранятся в виде одного длинного связного списка.

### Как же избегать коллизией?
Для уменьшения вероятности коллизий необходимо:
- Использовать хорошую хэш-функцию. Подразумевается, что возникает как можно меньше коллизий.
- Следить за *коэффициентом заполнения*.

**Коэффициент заполнения** - это отношение между количеством элементов в хэш-таблице и размером самой хэш-таблицы.

Проще говоря, отношение между количеством хранимых ключей и размером массива (хэш-таблицы).

Хэш-функция вообще должна возвращать правильные индексы, которые мы можем использовать. Если наш массив работает с 10 элементами, то и максимально возвращаемый индекс должен быть 9.

Поэтому хэш-функция получившийся хэш делит с остатком на размер массива. Она знает о его размере.

**Чем больше коэффициент заполнения, тем больше коллизий!**. Поэтому обычно после достижение коэффициента заполнения >= 0.7 увеличивать размер хэш-таблицы.

## Хэш-таблицы в Python
В Python есть несколько типов данных, основанных на хэш-таблицах: set (множество) и dict (словарь).

**Словарь:**
```python
telephon_book = {}

telephon_book["John"] = "+996500400300"
telephon_book["Jack"] = "+996700400300"
telephon_book["Jill"] = "+996550400300"

print(telephon_book)
print(telephon_book["Jack"]) # +996700400300
```

Если со словарем все понятно, то что насчет множества? У нас ведь просто есть значение. Ответ прост: это значением также будет являться и ключом.

**Множество:**
```python
names = set()

names.add("John")
names.add("John")
names.add("Alex")

print(names)
names.remove("John")
print(names)
```

## Big O хэш-таблиц

| Операция       | Средний случай | Худший случай |  
|----------------|----------------|---------------|  
| **Вставка**    | `O(1)`         | `O(n)`        |  
| **Поиск**      | `O(1)`         | `O(n)`        |  
| **Удаление**   | `O(1)`         | `O(n)`        |  

Худший случай подразумевает коллизии, а значит и поиск в связном списке.

## Заключение
- Хэш-таблица — это структура данных для хранения пар **ключ-значение** с быстрым доступом (в среднем `O(1)`).
- Использует **хэш-функцию** для преобразования ключа в индекс массива.  
- Требует **неизменяемые ключи**, чтобы хэш оставался постоянным.
-  Коллизии возникают, когда разные ключи дают одинаковый хэш.  
- Применяется для кэширования, удаления дубликатов (set), моделирования отношения между объектами (dict)
