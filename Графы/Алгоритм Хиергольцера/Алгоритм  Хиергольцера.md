# Что это?
**Алгоритм Хиергольцера** - это алгоритм для нахождения Эйлерова пути/цикла в графе.

## Идея алгоритма
1. Начинаешь в какой-то вершине.
2. Всегда идёшь по ещё не пройденному ребру.
3. Если ты застрял (все рёбра пройдены), ты вернулся в точку, где ещё **есть непройденные дорожки**, и оттуда начинаешь **вставлять** новый маршрут внутрь старого.
4. Повторяешь, пока не пройдёшь все рёбра.

### Реализация для неориентированного графа
Прежде чем начинать искать Эйлеров путь, нужно задаться вопросом - а есть ли он вообще в этом графе?

Будет предоставлена реализация для неориентированного графа, поэтому вспоминаем условия для существования такого пути в нем:
1. Граф связный
2. Степень всех вершин четная, кроме двух вершин - начала и конца пути.

#### Как проверить связность графа?
Связность неориентированного графа легко можно проверить обходом графа. Нужно лишь потом сравнить количество вершин в пути, получившемся в обходе с количеством вершин графа.

Мы можем использовать обход в ширину для этого - **BFS**:

```python
from collections import deque

def is_connected(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)

    while queue:
        vertex = queue.popleft()

        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

    return len(visited) == len(graph)
```

Далее нужно определить количество вершин с нечетной степенью. Для неориентированного графа их только ровно два, если есть Эйлеров путь, или же ноль, если есть Эйлеров цикл

```python
def has_eulerian_path_or_cicle(graph):
    odd_degree_vertices = 0

    for vertex in graph:
        degree = len(graph[vertex]) # степень вершины = количество соседей в неориентированном графе
        if degree % 2 != 0:
            odd_degree_vertices += 1

    return odd_degree_vertices == 2 or odd_degree_vertices == 0
```

И вот теперь, если наши условия удовлетворяются, можно приступать искать Эйлеров путь/цикл.

Вы можете перенести их в основную функцию алгоритма, а можете использовать как отдельные функции.

Сначала сама реализация, а затем пояснения:

```python
from collections import defaultdict
import copy

def hierholzer_safe(graph):
    # Копируем элементы графа
    local_graph = {v: list(neighbors) for v, neighbors in graph.items()}
    
    def find_start():
        for v in local_graph:
            if len(local_graph[v]) % 2 == 1:
                return v
        return next(iter(local_graph)) # Или же любую вершину, если все степени четные
    
    path = []
    stack = []
    current = find_start()

    while stack or local_graph[current]:
        if not local_graph[current]:
            path.append(current)
            current = stack.pop()
        else:
            stack.append(current)
            neighbor = local_graph[current].pop()
            local_graph[neighbor].remove(current)
            current = neighbor

    path.append(current)
    return path[::-1]
```

Кратко: сначала находим вершины, с которой начнем наш путь (`find_start`). После чего мы проходим по вершинам, пока у нее есть соседи.

Если соседей нет, то мы в тупике. Тогда добавляем нынешнюю вершину в путь и откатываемся назад через stack.
Иначе же добавляем текущую вершину в стек, а затем переходим к соседу, но не забываем удалить второе ребро

### Пояснение


Копируем граф.
```python
local_graph = {v: list(neighbors) for v, neighbors in graph.items()}
```

Мы не хотим портить оригинальный граф. Поэтому делаем копию — не всего словаря, а только **списки смежности**. Это нужно, потому что далее мы будем **удалять рёбра** (из списков).

Получается такое:

```python
graph['A'] = ['B', 'C']
→
local_graph['A'] = ['B', 'C']  # независимая копия списка
```


Находим стартовую вершину:

```python
def find_start():
    for v in local_graph:
        if len(local_graph[v]) % 2 == 1:
            return v
    return next(iter(local_graph))
```

По теореме Эйлера, если у графа есть две вершины нечётной степени — путь должен начинаться с одной из них.  
Если все степени чётные — можно начать с любой вершины, и тогда это будет **цикл**.

```python
path = []
stack = []
current = find_start()
```

- `path` — здесь будет собираться итоговый путь.
    
- `stack` — для откатов, когда достигли тупика.
    
- `current` — вершина, с которой начинаем обход.
    

Начинаем проходиться по графу

```python
while stack or local_graph[current]:
```
Пока можно идти дальше (по рёбрам) или есть стек, продолжаем.

И возникает два варианта событий:

Вариант 1: дошли до тупика

```python
if not local_graph[current]:
    path.append(current)
    current = stack.pop()
```

- Если у текущей вершины нет соседей — мы в тупике. Это значит, что часть Эйлерова пути завершена.  
- Добавляем вершину в `path`, и возвращаемся назад по стеку, чтобы продолжить с предыдущей вершины.

Вариант 2: есть куда идти

```python
else:
    stack.append(current)
    neighbor = local_graph[current].pop()
    local_graph[neighbor].remove(current)
    current = neighbor
```

Если у вершины есть соседи:
1. Сохраняем текущую вершину в стек.
2. Берём **первого соседа** (можно произвольно)   
3. Удаляем ребро из графа (в обеих направлениях — граф неориентированный!).
4. Двигаемся к соседу — он становится `current`.  


И в конце завершаем алгоритм:

```python
path.append(current)
return path[::-1]
```

Когда цикл завершён, последняя вершина ещё не добавлена — добавляем её.
Но! Мы собирали `path` в обратном порядке (с конца в начало). Поэтому делаем `[::-1]`, чтобы путь шёл от начала до конца.

### Временная сложность
Временная сложность алгоритма Хиергольцера - O(E),  где E - рёбра графа. Она получается за счет подсчета степеней и прохода по графу.

Однако наша реализация будет работать за O(V + E):
1. Мы создаем копию графа, а значит копируем и вершины, и ребра. Отсюда и O(E)
2. Ищем стартовую точку - O(V)
3. Проходимся по ребрам за O(E)
4. Получаем путь, не забывая его перевернуть также за O(E)

Можно слегка оптимизировать, и создавать копию графа с множествами вместо списков рёбер, однако это убирает у нас возможность работы с мультиграфом.





