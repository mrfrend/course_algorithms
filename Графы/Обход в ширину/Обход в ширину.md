## Что вообще такое BFS?
До этого мы рассматривали обход в ширину на деревьях, поэтому в представлении не считаю, что нуждается. Но если забыли, то коротко — это способ пройти по графу так, чтобы сначала пройти **всех ближайших** к стартовой вершине, потом — тех, кто чуть дальше, и так далее.  

Можно представить как если бы ты искал что-то на этажах здания: прошёл сначала весь первый этаж, потом поднялся на второй и так далее.

Именно так работает BFS: **слой за слоем**, **уровень за уровнем**.


## Как это работает? Представь ситуацию:

Ты хочешь продать свою умную колонку Алису, и тебе необходимо найти покупателя как можно ближнего к тебе, то есть знакомого.
Ты смотришь сначала на своих друзей, потом на друзей их друзей. То есть не лезешь вглубь, а сначала просматриваешь ближайшее окружение.

В алгоритмическом смысле — это как если бы ты:

1. Поместил стартовую вершину в очередь.
    
2. Пока очередь не пуста:
    
    - достаёшь вершину,
        
    - помечаешь её как посещённую,
        
    - и закидываешь туда всех её **непосещённых** соседей.
        

И так по кругу, пока не пройдем по всем вершинам.

---

## Главное: очередь, а не стек

Да, именно **очередь** — не перепутай.  

Если вместо этого использовать **стек**, получится совсем другой алгоритм — **обход в глубину (DFS)**. Там ты идёшь по одной ветке вглубь, пока можешь, и только потом возвращаешься.

## Зачем помечать пройденные вершины?

Чтобы не зациклиться и не проходить по одному и тому же месту несколько раз.

Без пометки посещенных мест:
- Алгоритм **никогда не закончится** — он будет всё время возвращаться к уже посещённым узлам.
- Ты **нагружаешь память**: в очередь постоянно попадают дубликаты.
- Ты **искажаешь результат** — BFS перестаёт быть корректным.



## Конкретный пример: как выглядит обход?
```python
A — B — C
|   |
D   E
```

**Запускаем BFS из A. Что будет происходить:**

1. Начинаем с A → кладём его в очередь
    
2. A достаём, отмечаем как посещённый → соседи: B и D → добавляем их в очередь  
    ➜ очередь: `[B, D]`, посещённые: `{A}`
    
3. Достаём B → соседи: A (уже был), C и E → добавляем C и E  
    ➜ очередь: `[D, C, E]`, посещённые: `{A, B}`
    
4. Достаём D → его сосед A уже посещён → ничего нового
    
5. Достаём C → его сосед B уже посещён
    
6. Достаём E → тоже всё уже видели
    

**Итоговый порядок обхода:** `A → B → D → C → E`

---

## Где применяется BFS?

- **Поиск кратчайшего пути** в **невзвешенном графе**. Подразумевается с наименьшим количество рёбер. 
    (Например, минимальное число станций между двумя точками метро)
- **Поиск выхода из лабиринта**, если можно идти только по "клеткам без стен"
- **Минимальное количество шагов в игре** (например, сколько ходов от старта до победы)
- **Соцсети** — чтобы узнать, насколько ты «далёк» от другого пользователя по общим друзьям
- **Проверка, связен ли граф**

---
## Визуально — как BFS проходит по графу слоями:
```python
     A
   /   \
  D     B
        |
        C
        |
        E

➤ Уровень 0: A  
➤ Уровень 1: D, B  
➤ Уровень 2: C, E
```

---

## Реализация на Python
Реализация простая и не очень отличается от BFS для бинарного дерева. Наш алгоритм принимает на вход сам граф и вершину, с которой мы начинаем обход:

```python
def bfs(graph, start):
    visited = set([start]) 
    queue = deque([start]) # сразу добавляем в очередь и в посещенные начальную вершину
    order = []

    while queue:
        vertex = queue.popleft()
        order.append(vertex)

        for neighbor in graph[vertex]:
            if neighbor not in visited: # Если мы еще не проходили к этой вершине
                visited.add(neighbor) # то добавим ее в посещенную
                queue.append(neighbor) # и в очередь
    return order
```

Вы можете запустить его для проверки с таким графом:
```python
graph = {"A": ["B", "D"], "B": ["A", "C", "E"], "C": ["B"], "D": ["A"], "E": ["B"]}
```

    