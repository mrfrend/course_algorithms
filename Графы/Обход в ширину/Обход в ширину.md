## Что вообще такое BFS?

Это способ пройти по графу так, чтобы сначала пройти **всех ближайших** к стартовой вершине, потом — тех, кто чуть дальше, и так далее.

Можно представить, как если бы ты искал что-то на этажах здания: прошёл сначала весь первый этаж, потом поднялся на второй и так далее.

Именно так работает BFS: **слой за слоем**, **уровень за уровнем**.

---

## Работа алгоритма на примере.

Ты хочешь продать свою умную колонку Алису, и тебе необходимо найти покупателя как можно ближе к тебе, то есть знакомого.
Ты сначала смотришь на своих друзей, потом на друзей их друзей. То есть не лезешь вглубь, а сначала просматриваешь ближайшее окружение.

В алгоритмическом смысле это выглядит так:

1. Помещаешь стартовую вершину в очередь.
2. Пока очередь не пуста:
   * достаёшь вершину,
   * **помечаешь её как посещённую**,
   * добавляешь в очередь всех её **непосещённых** соседей.

Повторяешь эти шаги, пока не пройдёшь все вершины.

---

## Зачем помечать пройденные вершины?

Чтобы не зациклиться и не проходить по одному и тому же месту несколько раз.

Если не помечать посещённые вершины:

* Алгоритм **никогда не закончится** — он будет всё время возвращаться к уже посещённым узлам.
* Ты **нагружаешь память**: в очередь будут попадать дубликаты.
* Ты **искажаешь результат** — BFS перестанет быть корректным.

---

## Где применяется BFS?

* **Поиск кратчайшего пути** в **невзвешенном графе** (например, минимальное число станций между двумя точками метро).
* **Поиск выхода из лабиринта**, если можно идти только по "клеткам без стен".
* **Минимальное количество шагов в игре** (например, сколько ходов от старта до победы).
* **Социальные сети** — чтобы узнать, насколько ты «далёк» от другого пользователя по общим друзьям.
* **Проверка связности графа**.

---

## Реализация на Python

Реализация проста и не сильно отличается от BFS для бинарного дерева. Алгоритм принимает на вход граф и стартовую вершину:

```python
from collections import deque

def bfs(graph, start):
    visited = set([start]) 
    queue = deque([start])  # сразу добавляем стартовую вершину в очередь и в посещённые
    order = []

    while queue:
        vertex = queue.popleft()
        order.append(vertex)

        for neighbor in graph[vertex]:
            if neighbor not in visited:  # если ещё не проходили к этой вершине
                visited.add(neighbor)    # помечаем как посещённую
                queue.append(neighbor)   # и добавляем в очередь
    return order
```

Для проверки запустите со следующими данными:

```python
graph = {
    "A": ["B", "D"],
    "B": ["A", "C", "E"],
    "C": ["B"],
    "D": ["A"],
    "E": ["B"]
}

print(bfs(graph, "A"))
# Выведет: ['A', 'B', 'D', 'C', 'E']
```
