
# Алгоритм Дейкстры

Представь, что ты в незнакомом городе. Стоишь на вокзале и хочешь узнать: как быстрее всего добраться до разных мест — магазина, университета, остановки. Но ты не хочешь идти куда попало. Тебе нужно **самое короткое** расстояние, маршрут или время.

Алгоритм Дейкстры как раз это и делает:  
он помогает найти **кратчайшие пути от одной точки до всех остальных** в системе дорог, станций или узлов — то есть в графе.

---

## Как работает

Допустим, у тебя есть граф (например, станции метро), где:

- **Вершины** — это станции: `A`, `B`, `C`, `D`, `E`
    
- **Рёбра с весами** — это время или расстояние между ними
    

Алгоритм:

1. Для всех вершин расстояние сначала считается бесконечным (`inf`), кроме стартовой — у неё 0. Под бесконечностью мы считаем, что мы до них еще не дошли и не имеем представления какое расстояние до этой вершины.
    
2. Создаётся список (или множество) **непосещённых вершин**.
    
3. Из них выбирается вершина с **наименьшим текущим расстоянием**.
    
4. Алгоритм проверяет всех соседей этой вершины и **обновляет расстояния**, если через неё путь стал короче.
    
5. Шаги повторяются, пока все вершины не пройдены.

Для не посещённых вершин используйте по возможности множество. Особенно если оно реализовано через хэш-таблицы. К тому же, нам важно какие уникальные вершины мы прошли, без разницы какой порядок.

## Ограничения алгоритма
- **Нельзя использовать с отрицательными весами рёбер**. Алгоритм предполагает, что если мы уже нашли кратчайший путь до вершины, пересматривать его не нужно. Но если есть отрицательные рёбра, может появиться более короткий путь _после_ — это ломает всё. Это алгоритм не учтёт. Для работы с отрицательными рёбрами существует алгоритм **Беллмана-Форда**.
- **Граф должен быть взвешенным** (т.е. веса рёбер заданы и известны). Алгоритм ищет путь **с минимальной суммой весов**. Если веса не заданы — что оптимизировать? Если граф не взвешенный, то лучше использовать обход в ширину - он позволит пройтись и найти кратчайший путь по количеству ребёр.
- **Циклы в графе допустимы**. Если мы ведем список посещенных вершин, то алгоритм просто пропустит цикл.
    
---
## Реализация на Python
Граф мы будем реализовывать через список смежности. Однако, в отличие от невзвешенного графа, нам необходимо хранить его вес. Поэтому каждым элементом списка будет не только название вершины, но и также вес - кортеж.

```python
graph = {
    'A': [('B', 2), ('C', 5)],
    'B': [('A', 2), ('C', 1), ('D', 4)],
    'C': [('A', 5), ('B', 1), ('D', 2)],
    'D': [('B', 4), ('C', 2)]
}
```


Важно отметить 3 шаг алгоритма - выбор вершины с наименьшим текущим расстоянием. Как это сделать? Первое в голову приходит решение через линейный поиск. Неплохо, но можно даже лучше. Для этого можно использовать очередь с приоритетом, а значит и кучу - min-heap, точнее. Это позволит нам каждый раз за O(log n) получать вершину с минимальным текущим расстоянием.

Теперь — реализация построчно.

```python
import heapq
```

Импортируем модуль `heapq` — это стандартная библиотека Python, реализующая **очередь с приоритетом на куче (heap)**.

---
Сам алгоритм будет опять реализован через функцию.
```python
def dijkstra(graph, start):
```

Объявляем функцию, которая получает:
- `graph` — словарь, где ключи — вершины, а значения — список соседей с весами,
- `start` — стартовая вершина.
    
---

А теперь идем по шаг нашего алгоритма:

**Шаг 1: Инициализация расстояний**  
```python
    shortest_dist = {node: float('inf') for node in graph}
    shortest_dist[start] = 0
```

Создаём словарь, где каждому узлу сопоставляем бесконечность (`inf`) — это означает, что путь туда пока неизвестен. Это и будет нашим итоговым ответом
Затем выставляем расстояние до начальной вершины = 0.

**Шаг 2: создание множества посещенных вершин**  
```python
    visited = set()
```

Чтобы не проверять вершины по второму кругу, а также для избегания циклов. Помечаем те, для которых кратчайшее расстояние уже найдено.

---
Теперь создаем приоритетную очередь.
```python
    pq = [(0, start)]
```

heapq` работает с кортежами, где первый элемент — приоритет.  
Здесь `0` — потому что это стартовая вершина.

---
Теперь начинаем проходиться по вершинам:

```python
    while pq: # пока наша очередь не пуста
	    current_dist, current_node = heapq.heappop(pq) #получаем вершину с наименьшим расстоянием
	    if current_node in visited: #Если мы обработали этот узел
            continue # пропускаем
            
        visited.add(current_node) 
        
	    for neighbor, weight in graph[current_node]: # проходимся по соседям нашей вершины
		    distance = current_dist + weight # добавляем к нашему рассматриваемому узлу вес соседа
		    if distance < shortest_dist[neighbor]: # если мы нашли более короткий путь
                shortest_dist[neighbor] = distance # то фиксируем это в нашей таблице
                heapq.heappush(pq, (distance, neighbor)) # добавляем для рассмотрения как следующий кусок нашего кратчайшего пути
		
    return shortest_dist
```

И возвращаем наш словарь с кратчайшими путями к вершинам.

Полная реализация.

```python
import heapq

def dijkstra(graph, start):
    shortest_dist = {node: float('inf') for node in graph}
    shortest_dist[start] = 0
    visited = set()
    pq = [(0, start)]

    while pq:
        current_dist, current_node = heapq.heappop(pq)

        if current_node in visited:
            continue
        visited.add(current_node)

        for neighbor, weight in graph[current_node]:
            distance = current_dist + weight
            if distance < shortest_dist[neighbor]:
                shortest_dist[neighbor] = distance
                heapq.heappush(pq, (distance, neighbor))

    return shortest_dist
```

---

## Про реализацию
Реализация неплохая, мы используем различные структуры и АТД для реализации алгоритма:
- heapq для реализации очереди с приоритетом и выбором минимального элемента за `O(log n)`
- Словари для быстрого доступа к элементам и модификации
- Множество

## Временная сложность
Временная сложность нашей реализации алгоритма в худшем случае будет  `O((V + E) * log V)`, где V - множество (количество) вершин, E - множество рёбер.

Смотрите, мы получаем вершину с минимальным расстоянием за `O(log n)`. Делаем мы это максимум V раз (для каждой вершины), отсюда `O(V log V)`.

Также мы можем обновлять соседей максимум `O(E)` раз → `O(E log V)` (так как каждое обновление сопровождается операцией вставки в кучу)

Отсюда и `O(E log V + V log V)` = `O((V + E) * log V)`

## А что насчет получения самого кратчайшего пути?
Такие алгоритмы, как Дейсктра и BFS позволяют ответить на два вопроса:
1. Найти кратчайший пути от вершины A до вершины B
2. Определить существует ли путь от вершины A до вершины B

Наша текущая реализация позволяет получить минимальные расстояния за которые можно дойти для каждой вершины.

Можно ли получить кратчайший путь? Да, легко. 

Наша функция теперь будет принимать не только начальной узел, но и конечный `end` - "*зачем это?*" выяснится в конце.

Мы  создадим еще одну хэш-таблицу, которая будет для каждого узла хранить его родителя, от которого и получается кратчайший путь.

```python
previous = {node: None for node in graph}
```

Затем при проходе по соседям узлам мы будем обновлять родителя этого соседа, но только если мы нашли кратчайший путь для этого узла

```python
if distance < shortest_dist[neighbor]:
	shortest_dist[neighbor] = distance
	previous[neighbor] = current_node # Обновляем предка
	heapq.heappush(pq, (distance, neighbor))
```

Теперь нам необходимо восстановить путь.

```python
path = []
current = end # это наш параметр функции
while current is not None:
	path.append(current)
	current = previous[current] # Получаем родителя вершины, или же часть пути до нашей вершины
path.reverse()
```

Здесь мы создаем список, который определяет наш путь. Начинаем с самого конца. Добавляем текущую вершину пути в `path`. Теперь нам надо перейти к предыдущей вершине нашего кратчайшего пути. А где эта вершина хранится? Правильно, в нашем словаре `previous`. Так мы делаем, пока не дойдем до начала - у начала нет предка, и `previous` его значение будет `None`

Однако мы получили путь с точностью да наоборот. Мы начали с конца и пришли к началу. Поэтому нам необходимо перевернуть наш список.

Не забудем его также вернуть пользователю из функции. 

---

## Выводы
Алгоритм Дейкстры используется для получения кратчайшего пути во взвешенным графе без отрицательных ребер. Наша реализация выполняется за `O((V + E) * log V)` времени.

По своей cути алгоритм ищет кратчайший путь до каждой вершины, а затем использует этот "подпуть' как часть для следующего "подпути" к другой вершине, и так далее. 


