# Алгоритм Дейкстры

Представь, что ты находишься в незнакомом городе. Стоишь на вокзале и хочешь узнать, как быстрее всего добраться до разных мест — магазина, университета, остановки. Но идти куда попало не хочется. Тебе нужен **самый короткий** маршрут по расстоянию или времени.

Алгоритм Дейкстры как раз решает эту задачу:
он помогает найти **кратчайшие пути от одной точки до всех остальных** в системе дорог, станций или узлов — то есть в графе.

---

## Как работает алгоритм

Допустим, у тебя есть граф (например, станции метро), где:

* **Вершины** — это станции: `A`, `B`, `C`, `D`, `E`
* **Рёбра с весами** — это время или расстояние между станциями

Алгоритм работает следующим образом:

1. Для всех вершин устанавливаем расстояние равным бесконечности (`inf`), кроме стартовой — у неё расстояние 0. Под бесконечностью понимается, что путь к этой вершине ещё не найден.
2. Создаётся множество непосещённых вершин.
3. Из них выбирается вершина с **наименьшим текущим расстоянием**.
4. Для каждого соседа выбранной вершины алгоритм проверяет, можно ли улучшить расстояние до него через текущую вершину, и обновляет расстояния при необходимости.
5. Шаги повторяются, пока все вершины не будут посещены.

Для непосещённых вершин рекомендуется использовать множество, особенно реализованное через хэш-таблицы, чтобы эффективно проверять принадлежность и избегать дубликатов.

---

## Ограничения алгоритма

* **Нельзя использовать с отрицательными весами рёбер.** Алгоритм предполагает, что после нахождения кратчайшего пути до вершины его можно не пересматривать. При отрицательных рёбрах более короткий путь может появиться позже, что нарушает логику алгоритма. Для работы с такими графами существует алгоритм **Беллмана-Форда**.
* **Граф должен быть взвешенным.** Алгоритм ищет путь с минимальной суммой весов. Если веса не заданы, оптимизировать нечего. Для невзвешенных графов лучше подходит обход в ширину (BFS), который ищет кратчайший путь по количеству рёбер.
* **Циклы в графе допустимы.** Если вершина уже посещена, алгоритм просто её пропускает, избегая зацикливания.

---

## Реализация на Python

Граф представим списком смежности, где каждому соседу соответствует вес ребра — кортеж `(вершина, вес)`:

```python
graph = {
    'A': [('B', 2), ('C', 5)],
    'B': [('A', 2), ('C', 1), ('D', 4)],
    'C': [('A', 5), ('B', 1), ('D', 2)],
    'D': [('B', 4), ('C', 2)]
}
```

---

Ключевой момент — выбор вершины с наименьшим расстоянием. Можно сделать линейный поиск, но лучше использовать очередь с приоритетом — мин-кучу (min-heap), что позволяет извлекать минимум за `O(log n)`.

Импортируем модуль для работы с кучей:

```python
import heapq
```

---

Теперь сама функция:

```python
def dijkstra(graph, start):
    shortest_dist = {node: float('inf') for node in graph} # шаг 1 алгоритма
    shortest_dist[start] = 0
    visited = set() # шаг 2
    pq = [(0, start)]  # очередь с приоритетом: (расстояние, вершина)

    while pq:
        current_dist, current_node = heapq.heappop(pq) # шаг 4

        if current_node in visited:
            continue
        visited.add(current_node)

        for neighbor, weight in graph[current_node]: # рассматриваем соседей текущей вершины
            distance = current_dist + weight
            if distance < shortest_dist[neighbor]: # если же полученное расстояние меньше текущего
                shortest_dist[neighbor] = distance # обновляем
                heapq.heappush(pq, (distance, neighbor))

    return shortest_dist
```

Функция возвращает словарь с кратчайшими расстояниями от `start` до каждой вершины.

---

## Временная сложность

Алгоритм работает за время `O((V + E) * log V)`, где `V` — количество вершин, а `E` — количество рёбер.


* Извлечение вершины с минимальным расстоянием из кучи — `O(log V)`, максимум `V` раз, отсюда `O(V log V)`
* Обновление расстояния для соседей — максимум `E` раз, вставка в кучу также `O(log V)` → `O(E log V)`
  Суммируя: `O((V + E) log V)`

---

## Как получить сам кратчайший путь?

Текущая реализация возвращает только длины кратчайших путей. Чтобы восстановить путь, нужно хранить для каждой вершины её **предка** — вершину, с которой мы пришли, обновив кратчайшее расстояние.

Добавим словарь для предков:

```python
previous = {node: None for node in graph}
```

Обновляем предка при улучшении расстояния:

```python
if distance < shortest_dist[neighbor]:
    shortest_dist[neighbor] = distance
    previous[neighbor] = current_node  # обновляем предка
    heapq.heappush(pq, (distance, neighbor))
```

---

После работы алгоритма можно восстановить путь от конечной вершины `end` к стартовой:

```python
path = []
current = end
while current is not None:
    path.append(current)
    current = previous[current]
path.reverse()
```

Таким образом мы идём по цепочке предков от конца к началу, а потом разворачиваем список, чтобы получить путь в правильном порядке.

---

## Полная версия с восстановлением пути

```python
import heapq

def dijkstra(graph, start, end=None):
    shortest_dist = {node: float('inf') for node in graph}
    shortest_dist[start] = 0
    visited = set()
    previous = {node: None for node in graph}
    pq = [(0, start)]

    while pq:
        current_dist, current_node = heapq.heappop(pq)

        if current_node in visited:
            continue
        visited.add(current_node)

        if current_node == end:
            break  # если указан конечный узел, можно остановиться раньше

        for neighbor, weight in graph[current_node]:
            distance = current_dist + weight
            if distance < shortest_dist[neighbor]:
                shortest_dist[neighbor] = distance
                previous[neighbor] = current_node
                heapq.heappush(pq, (distance, neighbor))

    if end is None:
        return shortest_dist

    # Восстановление пути
    path = []
    current = end
    while current is not None:
        path.append(current)
        current = previous[current]
    path.reverse()

    return shortest_dist[end], path
```

---

## Выводы

* Алгоритм Дейкстры — универсальный инструмент для поиска кратчайших путей во взвешенных графах без отрицательных рёбер.
* Время работы зависит от числа вершин и рёбер, а также от структуры данных (использование кучи ускоряет выбор минимального расстояния).
* С помощью дополнительного словаря предков можно не только получить длину пути, но и сам маршрут.

