## Что такое алгоритм Беллмана-Форда?

Алгоритм Беллмана-Форда — способ найти **кратчайшие пути от одной стартовой вершины до всех остальных** в ориентированном или неориентированном **взвешенном графе**, в котором **могут присутствовать отрицательные веса рёбер**.

Он даёт корректный результат **даже при наличии отрицательных весов**, чего не умеет делать алгоритм Дейкстры.

---

## Отличие Беллмана-Форда от Дейкстры

| Критерий                       | Беллман-Форд | Дейкстра                 |
| ------------------------------ | ------------ | ------------------------ |
| Поддержка отрицательных весов  | Да           | Нет                      |
| Поиск кратчайших путей         | Да           | Да                       |
| Выявление отрицательных циклов | Да           | Нет                      |
| Сложность по времени           | O(V × E)     | O((V + E) log V) с кучей |
| Производительность             | Медленнее    | Быстрее                  |

---

## Суть алгоритма

**Кратчайший путь из начальной вершины в любую другую не должен содержать более (V – 1) рёбер.** Почему?

* В графе с V вершинами **максимальное количество рёбер без повторений (без циклов)** — это **V – 1**.
* Если больше — значит, путь содержит цикл.

---

### Как работает

1. **Инициализация:** расстояния до всех вершин — бесконечность (`∞`), кроме стартовой — 0 (как у Дейкстры).
2. **V – 1 итерация:**
   Для каждого ребра (u → v) с весом w:
   Если `расстояние[u] + w < расстояние[v]`, обновляем `расстояние[v]`.
3. **Проверка на отрицательные циклы:**
   После всех итераций, если можно ещё улучшить расстояния, значит, в графе есть отрицательный цикл — алгоритм сообщает об этом.

---

## Почему именно V – 1 итерация?

Если кратчайший путь проходит через несколько вершин, то без циклов он не может содержать больше, чем V – 1 ребро. После этого количества шагов минимальные расстояния будут установлены.

Дополнительная проверка позволяет выявить отрицательные циклы — если расстояния можно улучшить, то цикл есть.

---

## Реализация на Python


```python
def bellman_ford(graph, start):
    shortest_dist = {node: float('inf') for node in graph}
    shortest_dist[start] = 0

    for _ in range(len(graph) - 1):
        for u in graph:
            for v, weight in graph[u]:
                if shortest_dist[u] + weight < shortest_dist[v]:
                    shortest_dist[v] = shortest_dist[u] + weight

    # Проверка отрицательных циклов
    for u in graph:
        for v, weight in graph[u]:
            if shortest_dist[u] + weight < shortest_dist[v]:
                raise ValueError("Обнаружен отрицательный цикл")

    return shortest_dist
```

---
## Главное отличие от Дейкстры

1. **Нет множества посещённых вершин.** Мы не "закрепляем" вершину с найденным кратчайшим расстоянием, так как пути могут улучшаться.
2. **Нет очереди с приоритетом.** Мы просто перебираем все ребра `V – 1` раз.
3. **Работа с отрицательными весами и выявление отрицательных циклов.**

---

## Аналогии

* **Дейкстра — упрямый собеседник:** как только сформировал мнение (кратчайший путь до вершины), не меняет его. Быстрый, но слеп к отрицательным весам.
* **Беллман-Форд — скептик:** постоянно проверяет и пересматривает свои решения, не доверяя первоначальным выводам. Медленнее, но надёжнее.

---

## Временная сложность

Алгоритм Беллмана-Форда работает за `O(V × E)`, где `V` — количество вершин, `E` — количество рёбер.

Это значительно медленнее Дейкстры, особенно на больших графах.
