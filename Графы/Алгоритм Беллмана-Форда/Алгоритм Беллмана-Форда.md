## Что такое алгоритм Беллмана-Форда?

Алгоритм Беллмана-Форда — это способ найти **кратчайшие пути от одной стартовой вершины до всех остальных** в ориентированном или неориентированном **взвешенном графе**, в котором **могут присутствовать отрицательные веса рёбер**.

Он даёт корректный результат **даже тогда, когда в графе есть отрицательные веса**, чего не умеет делать алгоритм Дейкстры.

---

## Отличие Беллмана-Форда и Дейкстры

| Критерий                       | Беллман-Форд | Дейкстра                 |
| ------------------------------ | ------------ | ------------------------ |
| Поддержка отрицательных весов  | Да           | Нет                      |
| Поиск кратчайших путей         | Да           | Да                       |
| Выявление отрицательных циклов | Да           | Нет                      |
| Сложность по времени           | O(V × E)     | O((V + E) log V) с кучей |
| Производительность             | Медленнее    | Быстрее                  |

---

## Суть алгоритма

**Предположим, что кратчайший путь из начальной вершины в любую другую не должен проходить более чем через (V – 1) рёбер**. Почему так?

> В графе с V вершинами **максимальное количество рёбер без повторений** (то есть без циклов) — это **V – 1**.  
> Больше рёбер — значит, ты **ходишь по кругу**.

### Как работает
1. **Инициализация**: расстояние до всех вершин — бесконечность (`∞`), кроме стартовой (`0`). Начало как у Дейкстры.
2. **V – 1 итераций**:
    - Для **каждого ребра** (u → v, вес w):
        - Если `расстояние[u] + w < расстояние[v]`, то обновляем `расстояние[v]`.
            
3. **Проверка на отрицательные циклы**:
    - Если после всех итераций расстояния **ещё можно улучшить**, то в графе есть цикл с отрицательным весом.
        

---

## Почему V – 1 итераций?

Представь, что кратчайший путь от вершины A до вершины D идёт через:  
**A → B → C → D**

Если в графе **V вершин**, то самый длинный возможный путь без циклов может содержать **не более V – 1 рёбер**. То есть **V – 1 шагов достаточно**, чтобы «распространить» минимальные расстояния во все направления.

В конце алгоритм **ещё раз** проверяет все рёбра. Если он **находит путь, который можно улучшить**, значит, ты можешь бегать по циклу и получать всё более и более выгодный путь. Такой граф **неподходящий** для поиска устойчивого кратчайшего пути.

## Реализация на Python
```python
def bellman_ford(graph, start):
	# Все непосещенные вершины помечаем бесконечностью
    shortest_dist = {node: float('inf') for node in graph}
    shortest_dist[start] = 0

    for _ in range(len(graph) - 1):
        for u in graph:
            for v, weight in graph[u]: # Проходимся по соседям графа
                if shortest_dist[u] + weight < shortest_dist[v]:
                    shortest_dist[v] = shortest_dist[u] + weight

    for u in graph: # Последняя проверка на отрицательные циклы в графе
        for v, weight in graph[u]:
            if shortest_dist[u] + weight < shortest_dist[v]:
                raise ValueError("Обнаружен отрицательный цикл")

    return shortest_dist
```


Какие отличия от Дейкстры?
1. **Мы не помечаем вершины как пройденные**. Для этого использовалось множество.
2. Мы не выбираем вершину с минимальным расстоянием. Мы не используем очередь с приоритетом через кучу.
3. Мы проходимся V - 1 раз **по всем ребрам графа**.

Для более простого понимания приведу аналогию:
- Алгоритм Дейкстра - это упрямый собеседник. После того, как он сформулировал мнение (или же краткий маршрут до вершины), он его менять не будет (не возвращается к нему). Он **уверен, что больше других более коротких путей не существует до этой вершины.** Это позволяет ему быстро переходить к следующей вершине
- Алгоритм Беллмана-Форда - это скептик. И даже к своему мнению. Даже если он находит короткий маршрут до вершины, он не считает, что так и есть. Он к ней возвращается снова и снова. Это занимает намного больше времени, однако и результат правильный.

Или же другая аналогия:
- Дейкстра - рациональный навигатор. Начинает с текущей точки, всегда идёт **по самому короткому известному пути**. Он не возвращается назад — как только метка «расстояние минимальное» поставлена, он считает, что путь найден. Работает быстро, **но слеп** к отрицательным весам (думает, что все дороги либо нейтральны (0), либо затратны).
- Беллман-Форд - терпеливый строитель маршрутов. Рассматривает все дороги, независимо от того, что уже было посчитано раньше. Поэтому даже если в начале путь кажется невыгодным, он даст ему шанс позже.

Надеюсь, стало понятнее. Для визуализации рекомендую посмотреть этот ролик - https://www.youtube.com/watch?v=j0OUwduDOS0&ab_channel=b001. Он на английском, однако вы можете использовать перевод ролика от Яндекс браузера.

## Временная сложность
Временная сложность алгоритма Беллмана-Форда - `O(VE)`, где V - количество вершин, а E - количество ребер.

Намного медленнее алгоритма Дейкстры.

И правда. Суммарно мы проходимся по каждому ребру V - 1 раз. А также в конце еще один раз для проверки наличия отрицательных циклов.

