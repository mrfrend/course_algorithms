# Что такое сортировка выбором?**  
**Сортировка выбором (Selection Sort)** - алгоритм сортировки, который на каждом шаге находит минимальный (или максимальный) элемент в неотсортированной части массива и перемещает его в начало (или конец).  

Представьте, что у вас есть колода карт, разложенных в случайном порядке. Вы ищете самую младшую карту, кладете ее в начало, затем ищете следующую по старшинству среди оставшихся и так далее, пока вся колода не будет отсортирована.  

## Реализация сортировки выбором (по минимальному элементу)
```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr
```

## Объяснение
По структуре алгоритм напоминает сортировку пузырьками:
- Два цикла
- Внутренний цикл определяет минимальный элемент из нерасcмотренных.
- Внешний цикл повторяет этот процесс n - 1 раз, а затем ставит минимальный элемент на свою позицию.

С каждым разом отсортированная часть массива (начиная с начала, а не с конца как в bubble sort) увеличивается, и мы начинаем искать минимум с неотсортированной части массива.

Проделаем алгоритм на примере.

**Исходный массив:** `[5, 3, 8, 4, 2]`  

### **Проход 1:**  
- **Неотсортированная часть:** `[5, 3, 8, 4, 2]` (индексы `0..4`)  
- **Находим минимум:** `2` (индекс `4`)  
- **Меняем `5` и `2`:**  
  `[**2**, 3, 8, 4, **5**]`  

**Результат:** `[2, 3, 8, 4, 5]` (отсортированная часть: `[2]`)  

### **Проход 2:**  
- **Неотсортированная часть:** `[3, 8, 4, 5]` (индексы `1..4`)  
- **Находим минимум:** `3` (индекс `1`)  
- **Меняем `3` с самим собой (ничего не меняется)**  

**Результат:** `[2, 3, 8, 4, 5]` (отсортированная часть: `[2, 3]`)  

### **Проход 3:**  
- **Неотсортированная часть:** `[8, 4, 5]` (индексы `2..4`)  
- **Находим минимум:** `4` (индекс `3`)  
- **Меняем `8` и `4`:**  
  `[2, 3, **4**, **8**, 5]`  

**Результат:** `[2, 3, 4, 8, 5]` (отсортированная часть: `[2, 3, 4]`)  

### **Проход 4:**  
- **Неотсортированная часть:** `[8, 5]` (индексы `3..4`)  
- **Находим минимум:** `5` (индекс `4`)  
- **Меняем `8` и `5`:**  
  `[2, 3, 4, **5**, **8**]`  

**Результат:** `[2, 3, 4, 5, 8]` (отсортированная часть: `[2, 3, 4, 5]`)  

Как видим, для массива из 5 элементов мы прошлись только 4 раза (n - 1), так как самый максимальный элемент в конце будет уже стоять на своем месте.

Повторюсь еще раз, c каждым разом отсортированная часть массива (начиная с начала) увеличивается, и мы начинаем искать минимум с неотсортированной части массива.

Из-за этого во внутреннем цикле мы начинаем проход с `i + 1` элемента:

```python
...
# Внешний цикл
min_idx = i
	for j in range(i + 1, n):
		if arr[j] < arr[min_idx]:
		...
```

+1 добавляется из-за того, что мы считаем перед проходом минимальным элементом `i`: нет смысла делать первую проверку на неравенство с ним же, отсюда `i + 1`.

## Big O  
- Временная сложность:  O(n²) (даже если массив уже отсортирован, потому что алгоритм все равно проходит по всем элементам).  
- Пространственная сложность: O(1) (сортировка на месте, без дополнительной памяти).  

## Когда использовать?  
- На небольших массивах (из-за `O(n²)`).  
- В случаях, когда важно минимизировать количество обменов (например, если операции записи дорогие).  
- В учебных целях (алгоритм прост для понимания, но неэффективен на больших данных).  