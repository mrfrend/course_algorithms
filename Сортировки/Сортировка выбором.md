# Что такое сортировка выбором?

**Сортировка выбором (Selection Sort)** — это алгоритм сортировки, который на каждом шаге находит минимальный (или максимальный) элемент в неотсортированной части массива и перемещает его в начало (или конец).

Представьте, что у вас есть колода карт, разложенных в случайном порядке. Вы ищете самую младшую карту, кладёте её в начало, затем ищете следующую по старшинству среди оставшихся — и так далее, пока вся колода не будет отсортирована.

## Реализация сортировки выбором (по минимальному элементу)

```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr
```

## Объяснение

Алгоритм похож по структуре на пузырьковую сортировку:

* Два вложенных цикла.
* Внутренний цикл ищет **минимальный элемент** в неотсортированной части массива.
* Внешний цикл отвечает за то, чтобы по очереди **переместить этот минимум в начало** неотсортированной части.

С каждым проходом отсортированная часть массива (начиная **с начала**, в отличие от bubble sort, где элементы "всплывают" к концу) увеличивается, и поиск минимума начинается **в оставшейся неотсортированной части**.

Рассмотрим пример:

**Исходный массив:** `[5, 3, 8, 4, 2]`

---

### **Проход 1:**

* **Неотсортированная часть:** `[5, 3, 8, 4, 2]` (индексы `0..4`)
* **Минимум:** `2` (индекс `4`)
* **Меняем `5` и `2`:**
  → `[**2**, 3, 8, 4, **5**]`

**Отсортированная часть:** `[2]`

---

### **Проход 2:**

* **Неотсортированная часть:** `[3, 8, 4, 5]` (индексы `1..4`)
* **Минимум:** `3` (индекс `1`)
* **Меняем `3` с самим собой** (ничего не меняется)

**Отсортированная часть:** `[2, 3]`

---

### **Проход 3:**

* **Неотсортированная часть:** `[8, 4, 5]` (индексы `2..4`)
* **Минимум:** `4` (индекс `3`)
* **Меняем `8` и `4`:**
  → `[2, 3, **4**, **8**, 5]`

**Отсортированная часть:** `[2, 3, 4]`

---

### **Проход 4:**

* **Неотсортированная часть:** `[8, 5]` (индексы `3..4`)
* **Минимум:** `5` (индекс `4`)
* **Меняем `8` и `5`:**
  → `[2, 3, 4, **5**, **8**]`

**Отсортированная часть:** `[2, 3, 4, 5]` — почти весь массив, осталось одно число, и оно уже на своём месте.

---

Как видно, при массиве длины 5 мы делаем **4 прохода** (n - 1), так как к последнему элементу мы приходим уже с полностью отсортированной частью.

Почему внутренний цикл начинается с `i + 1`?

```python
min_idx = i
for j in range(i + 1, n):
    if arr[j] < arr[min_idx]:
        min_idx = j
```

Перед началом внутреннего цикла мы предполагаем, что **текущий элемент (`arr[i]`) — минимальный**, поэтому начинаем поиск минимума с **i + 1**, чтобы не сравнивать элемент сам с собой.

## Big O

* **Временная сложность:**

  * **Во всех случаях:** **O(n²)**
    Даже если массив уже отсортирован, алгоритм всё равно выполнит n(n - 1)/2 сравнений.
* **Пространственная сложность:** **O(1)** (сортировка на месте, без использования дополнительной памяти).

## Когда использовать?

* На **небольших массивах**, где сложность O(n²) не является критичной.
* В случаях, когда важно **минимизировать количество обменов** — например, если операции записи во внешний носитель дороги.
* В **учебных целях** — алгоритм прост для понимания, даже несмотря на свою неэффективность для больших объёмов данных.

---

## Заключение

**Selection Sort** — простой, но неэффективный алгоритм сортировки. Он понятен для изучения, легко реализуется и предсказуемо работает, но **медленный** на больших данных.
