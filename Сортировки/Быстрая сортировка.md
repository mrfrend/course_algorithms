# Что такое быстрая сортировка (Quick Sort)?

**Быстрая сортировка** — это рекурсивный алгоритм сортировки, который использует стратегию **"разделяй и властвуй"** и в среднем работает быстрее других классических методов сортировки.

---

## Принцип работы

Представьте, что вы сортируете книги по алфавиту:

1. Вы выбираете одну книгу — **опорную** (*pivot*).
2. Делите оставшиеся книги на две стопки:
   * те, что идут **раньше** опорной — налево
   * те, что **позже** — направо
3. Повторяете то же самое для каждой стопки.

---

### Базовый случай:

Массив из 0 или 1 элемента — уже отсортирован. Просто возвращаем.

```python
if len(arr) < 2:
    return arr
```

### Рекурсивный случай:

1. Выбираем опорный элемент
2. Разбиваем массив на:

   * `less`: элементы < pivot
   * `greater`: элементы > pivot
   * (опционально) `equals`: элементы == pivot
3. Рекурсивно сортируем `less` и `greater`
4. Объединяем результат:
   `sorted = quick_sort(less) + [pivot] + quick_sort(greater)`


Рассмотрим на следующем примере - `[3, 5, 1]`:

1. Опорный элемент: `3`
2. `less = [1]`, `greater = [5]`
3. Рекурсивно сортируем `less` и `greater`. Сейчас это базовые случаи
4. Ответ: `[1] + [3] + [5] = [1, 3, 5]`

---

## Реализация

```python
def quick_sort(arr: list) -> list:
    if len(arr) < 2:
        return arr
    else:
        pivot = arr[0]
        less = [el for el in arr[1:] if el <= pivot]
        greater = [el for el in arr[1:] if el > pivot]
        return quick_sort(less) + [pivot] + quick_sort(greater)
```

В классическом варианте pivot — это первый элемент. Но **если массив уже отсортирован**, это приведёт к **переполнению стека** и времени `O(n²)`. В таком случае один из подмассивов всегда будет пустой, что будет создавать рекурсию с большей глубиной - `O(n)`, а не `O(log n)`.


Для уменьшения шансов возникновения худшего случая лучше использовать случайный элемент:

```python
import random

def quick_sort(arr: list[int]) -> list[int]:
    if len(arr) < 2:
        return arr
    pivot = random.choice(arr)
    less = [el for el in arr if el < pivot]
    equals = [el for el in arr if el == pivot]
    greater = [el for el in arr if el > pivot]
    return quick_sort(less) + equals + quick_sort(greater)
```

---

## Временная и пространственная сложность

| Сложность  | Лучший случай                | Средний случай | Худший случай |
| ---------- | ---------------------------- | -------------- | ------------- |
| **Время**  | `O(n log n)`                 | `O(n log n)`   | `O(n²)`       |
| **Память** | `O(log n)` (в стеке вызовов) | `O(log n)`     | `O(n)`        |

> В среднем quick sort — **быстрее**, чем merge sort, несмотря на худший случай. Почему? Из-за **меньших констант**, которые опускаются в нотации Big O.

---

## Почему O(n log n) в среднем?

1. На каждом уровне:

   * делим массив → O(log n) уровней
   * на каждом уровне делаем O(n) сравнений (весь массив)
2. Всего: O(n) × O(log n) = **O(n log n)**

---

## Quick Sort и Merge Sort

| Характеристика       | Quick Sort                          | Merge Sort                     |
| -------------------- | ----------------------------------- | ------------------------------ |
| Время (среднее)      | `O(n log n)`                        | `O(n log n)`                   |
| Время (худшее)       | `O(n²)`                             | `O(n log n)`                   |
| Память               | `O(log n)` (in-place)               | `O(n)`                         |
| Скорость на практике | Быстрее (меньше накладных расходов) | Чаще используется в LinkedList |
| Стабильность         | нет                               | да                           |

Даже несмотря на худший случай, **Quick Sort** часто предпочтительнее — он быстрее в большинстве ситуаций.

---

## Заключение

* Quick Sort — мощный алгоритм сортировки с рекурсией
* В среднем работает за `O(n log n)`
* Рекурсивно делит массив относительно опорного элемента
* Использует стратегию **«разделяй и властвуй»**
* При неудачном выборе опорного элемента — **O(n²)**
