# Что такое быстрая сортировка?
**Быстрая сортировка (Quick sort)** считается самым быстрым алгоритмом сортировки. Его чаще всего и используют в реальных программах.


Представьте, что вы сортируете книги на полке по алфавиту:
1. Выбираете одну книгу (pivot).
2. Книги, названия которых идут раньше в алфавитном порядке, ставите слева, остальные — справа.
3. Повторяете процесс для каждой стопки.


Теперь на примере рассмотрим быструю сортировку.
Быстрая сортировка основывается на стратегию разделяй и властвуй. А значит, она реализовывается через рекурсию.

Входные данные: массив
Выходные данные: отсортированный массив


Давайте представим, что входными данными для нашей функции пришел пустой массив. В нем ноль элементов. Что бы мы сделали? Просто вернули его! Сортировать нет необходимости.
А если бы пришел массив только из одного элемента? Тоже просто вернули массив. 

Получается, когда массив пустой или состоит из одного элемента, мы не будем ничего делать, сортировать нечего. Это и есть наш базовый случай - **мы ничего не должны сортировать**:
```python
def quick_sort(arr: list) -> list:
	if len(arr) < 2: # если массив пустой или из одного элемента
		return arr # просто возвращаем его
	else:
		#рекурсивный случай
		...
```

А если пришел массив из 2-ух и больше элементов? Что теперь? Опять разбираемся по порядку.
Если в массиве всего два элемента, то просто сравниваем 1-ый элемент со 2-ым и при необходимости меняем местами.

Пока мы знаем как сортировать пустой массив, а также массив из 1-2 элементов.

А вот начиная с трех элементов быстрая сортировка предлагает следующие шаги:
1. Определить из массива опорный элемент. Это элемент, с которым будут сравниваться другие элементы массива.
2. Определить массив, элементы которого меньше или равны опорного элемента.
3. Определить массив, элементы которого больше опорного элемента.

Вот мы получили два массива, одни элементы которого больше опорного элемента, а другие меньше либо равны ему. Эти массивы неотсортированны. Но если бы мы их отсортировали, то можно было получить отсортированный массив таким образом:
```python
return sorted_less + [pivot_element] + sorted_higher
```

Как мы это сделаем? Вызвав саму функцию quick_sort. Давайте на примере следующего массива `[3,5,1]`.
1. Определяем опорный элемент. Пусть это будет первый элемент массива - 3.
2. Определяем подмассив меньших либо равных элементов - `[1]`
3. Определяем подмассив больших элементов - `[5]`

Мы получили два базовых случая - массивы из одного элемента. С ними наша функция легко выполнит свое предназначение. Получается, массив из трех элементов можно отсортировать следующим образом:
```python
def quick_sort(arr: list) -> list:
	if len(arr) < 2: # если массив пустой или из одного элемента
		return arr # просто возвращаем его
	else:
		pivot = arr[0] # опорный элемент
        less = [el for el in arr[1:] if el <= pivot] # массив меньших либо равных элементов опорному
        greater = [el for el in arr[1:] if el > pivot] # массив элементов больших опорного
        return quick_sort(less) + [pivot] + quick_sort(greater)
		...
```

А если входными данными стал массив из 4-ех элементов? Например, `[3,1,0,-1]`? После выбора опорного элемента - 3, получатся следующие подмассивы:
```python
[1, 0, -1]
[] # нет элементов больше опорного
```
Мы уже знаем, что можем отсортировать массив из трех элементов выше: в итоге он тоже достигнет базового случая. Получаетcя, и массив из 4-ех элементов можно отсортировать.

Тоже самое и с массивами из 5 элементов, 6 элементов и так далее.

Сами того не подозревая, мы воспользовались *доказательством по методу индукции*. Вообще, разделяй и властвуй связано с доказательством по методу индукции. Рекомендуется внимательно изучить.

### Временная сложность быстрой сортировки
Временная сложность быстрой сортировки **в среднем случае** O(n log n). Почему именно такая?

Давайте посчитаем временную сложность нашего алгоритма. Будем ориентироваться на худший случай.

```python
def quick_sort(arr: list) -> list:
	if len(arr) < 2:
		return arr
	else:
		pivot = arr[0]
        less = [el for el in arr[1:] if el <= pivot] 
        greater = [el for el in arr[1:] if el > pivot]
        return quick_sort(less) + [pivot] + quick_sort(greater)
		...
```

1. `len(arr) < 2`. Выполняется функция `len(arr)`. Ее временная сложность будет O(n)
2. Базовый случай не выполняется (так как мы ориентируемся на худший случай)
3. Проход по массиву для переменной `less`. O(n)
4. Проход по массиву для переменной `greater`. O(n)

Рекурсивные вызовы мы будем считать отдельно.

Итак, без рекурсивных вызовов временная сложность алгоритма быстрой сортировки есть O(3n) = O(n). Линейная.

Разберемся с рекурсией. **Рекурсия** - это вызов функции самой себя. Получается, наши действия выше будут повторяться какое-то количество раз. Это количество раз в среднем равно O(log2n) = O(logn), что равняется *глубине рекурсии*.
Итого получается O(n) \* O(log n) = O(n logn).

Обратите внимание, что мы рассмотрели средний случай. В худшем случае алгоритм работает за O(n^2). 

**Такой случай возникает, когда на вход передается уже отсортированный массив**. Каждый раз у нас будет одна пустая половина (если мы берем 1-ый элемент каждый раз в качестве опорного), из-за чего мы будем делать больше вызовов вглубь для второго массива. 

И таких вызовов вглубь будет равняться размерности нашего массива, то есть тоже O(n). Отсюда O(n) \* O(n) = O(n^2). 

Поэтому рекомендуется в качестве опорного элемента каждый раз выбирать случайный элемент массива, а не первый. Так мы уменьшаем шансы на худший случай.

### Сортировка слиянием и быстрая сортировка

У обоих алгоритмов одинаковая временная сложность - O(n logn). Однако у сортировки слиянием она постоянна. А вот у быстрой сортировки нет.

Почему же тогда используют быструю сортировку? **Все дело в том, что хоть и временная сложность одна и та же, константы разные**. Эти константы влияют на количество операций. И так получается, что в быстрой сортировки эта константа меньше.
**Но так как мы используем нотацию Big O, мы эту константу убираем.**

Если не понятно, то представьте, что есть функция, которая выводит все элементы массива:
```python
def print_items(arr: list):
	for item in arr:
		print(item)
```

Такая функция работает за O(n).

А вот есть другая функция, вот только она еще приостанавливается на секунду для каждого элемента.
```python
import time
def print_items(arr: list):
	for item in arr:
		time.sleep(1)
		print(item)
```

Такая функция  тоже работает за O(n). Но что же будет работать быстрее?  Первая функция. И не только по времени, а по количеству операций:
1. Первая функция T(n) = n. В цикле выводим лишь каждый раз элемент.
2. Вторая функция T(n) = 2n. В цикле дополнительно выполняем `time.sleep(1)`

И вот эту константу мы и отпускаем. Поэтому выбирайте случайный элемент в качестве опорного и пользуйтесь по возможности быстрой сортировкой.

Новая версия алгоритма быстрой сортировки на Python:
```python
def quick_sort(arr: list[int]) -> list[int]:
    if len(arr) < 2:
        return arr
    else:
        pivot = random.choice(arr) # теперь выбираем случайный опорный элемент
        less = [el for el in arr if el < pivot]
        equals = [el for el in arr if el == pivot]
        greater = [el for el in arr if el > pivot]
        # добавляется дополнительный проход, так как мы теперь не знаем какой у нас опорный элемент изначально

        return quick_sort(less) + equals + quick_sort(greater)
```

## Big O быстрой сортировки
|Сложность|Лучший|Средний|Худший|
|---|---|---|---|
|**Время**|`O(n log n)`|`O(n log n)`|`O(n²)`|
|**Память**|`O(n)`|`O(n)`|`O(n²)`|