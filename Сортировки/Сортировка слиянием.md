# Что такое сортировка слиянием?

Представьте, что вам нужно отсортировать стопку карт:

- Разделите её на две части. Даже если количество карт нечётное — одна часть будет просто на одну карту больше.
- Отсортируйте каждую из них
- Сливайте карты обратно, по одной за раз, всегда выбирая меньшую из верхних двух

По такому приниципу и работает данный алгоритм.

**Сортировка слиянием (Merge Sort)** — это алгоритм сортировки, который:

1. Рекурсивно делит массив на две части
2. Сортирует каждую из них
3. Сливает отсортированные части в один отсортированный массив

---

## Стратегия «разделяй и властвуй»

Сортировка слиянием использует стратегию «разделяй и властвуй»

Это стратегия, при которой задача:

1. **Разбивается** на подзадачи меньшего размера
2. Каждая подзадача решается **по той же схеме** (рекурсивно)
3. Результаты объединяются в итоговое решение

## Эта стратегия почти всегда реализуется через **рекурсию**.

## Базовый случай и рекурсивный случай

- **Базовый случай**: массив из 1 или 0 элементов — уже отсортирован, возвращаем как есть.
- **Рекурсивный случай** (массив из двух и более элементов):

  1. Разделяем массив пополам
  2. Сортируем левую и правую половины рекурсивно
  3. Сливаем их, сравнивая элемент поочерёдно

---

## Проверка на примерах

- `[10, 5]` → разбивается на `[10]` и `[5]`
  Каждая часть — базовый случай → сортируется → затем сливается
- `[120, 34, 57]` → делится на `[120, 34]` и `[57]`
  `[120, 34]` → делится на `[120]` и `[34]` → базовые случаи

Вывод: любой массив через деление рекурсивно сводится к простейшим подмассивам длины 1.

---

## Реализация

### 1. Функция `merge_sort` — основа

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr  # базовый случай

    middle = len(arr) // 2
    left = merge_sort(arr[:middle])
    right = merge_sort(arr[middle:])

    return merge(left, right)
```

### 2. Функция `merge` — слияние двух отсортированных массивов

```python
def merge(left, right):
    result = []
    i = j = 0

    # Пока оба массива не закончились
    while i < len(left) and j < len(right):
        if left[i] <= right[j]: # если элемент левого массива меньше элемента правого массива
            result.append(left[i])
            i += 1 # переходим и сравниваем со следующим, более большим элементом левого массива.
        else:
            result.append(right[j])
            j += 1

    # Добавляем оставшиеся элементы
    result.extend(left[i:])
    result.extend(right[j:])

    return result
```

---

## Пример работы `merge`

```python
left = [3, 7, 10]
right = [2, 5, 9]
result = merge(left, right)
```

| Шаг | Сравнение       | Добавляем в `result` | Остаток          |
| --- | --------------- | -------------------- | ---------------- |
| 1   | `3 <= 2` → нет  | `2`                  | `right → [5, 9]` |
| 2   | `3 <= 5` → да   | `3`                  | `left → [7, 10]` |
| 3   | `7 <= 5` → нет  | `5`                  |                  |
| 4   | `7 <= 9` → да   | `7`                  |                  |
| 5   | `10 <= 9` → нет | `9`                  |                  |
| 6   | Остаток `left`  | `10`                 |                  |

**Итог**: `[2, 3, 5, 7, 9, 10]`

---

## Полная реализация

```python
def merge(left, right):
    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])
    return result

def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    middle = len(arr) // 2
    left = merge_sort(arr[:middle])
    right = merge_sort(arr[middle:])

    return merge(left, right)
```

---

## Временная и пространственная сложность

| Характеристика     | Оценка         | Почему?                          |
| ------------------ | -------------- | -------------------------------- |
| Время (все случаи) | **O(n log n)** | log n делений × O(n) слияний     |
| Пространство       | **O(n)**       | создаётся новый массив размера n |

---

## Когда использовать сортировку слиянием?

- Нужна **стабильная сортировка**
- Требуется **предсказуемое время выполнения** (нет худшего случая как в Quick Sort)
- Работаешь с **связными списками** (можно сделать сортировку in-place)

## Заключение

- **Merge Sort** — это рекурсивный алгоритм, основанный на **"разделяй и властвуй"**
- Делит массив до тех пор, пока не останутся подмассивы из одного элемента
- Затем **сливает отсортированные подмассивы**
- Гарантирует **O(n log n)** в любом случае
- Подходит для стабильной сортировки и задач с детерминированной сложностью
