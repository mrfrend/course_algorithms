# Что такое сортировка слиянием?
**Сортировка слиянием (Merge Sort)** — это алгоритм сортировки, который рекурсивно разделяет массив на две части, сортирует каждую из них, а затем объединяет (сливает) отсортированные части в один массив.

Представьте, что вам нужно отсортировать колоду карт:
1. Разделите колоду на две равные части.
2. Отсортируйте каждую половину отдельно.
3. Затем объедините две отсортированные половины в одну колоду, последовательно выбирая меньшую карту из верхних карт каждой стопки.

Однако массив может хранить и нечетное количество элементов: в этом случае одна из половин будет на один элемент больше.

## Разделяй и властвуй
Прежде чем начать, необходимо узнать о  "разделяй и властвуй".

**Разделяй и властвуй** - это стратегия, подход к решению задачи. При такой стратегии задача делится на подзадачи (задачи меньшего размера) до тех пор, пока не будет достигнут *базовый случай*.

Решение задачи методом "разделяй и властвуй" состоит из двух шагов: 
1. Сначала определяется базовый случай. Это должен быть простейший случай из всех возможных. В таком случае мы знаем как решить задачку
2. Задача делится или сокращается до тех пор, пока не будет сведена к базовому случаю

Похоже на условия рекурсии, не так ли? Именно так. ***Алгоритмы на базе стратегии разделяй и властвуй реализуют с помощью рекурсии.***

Сортировка слиянием также использует стратегию "разделяй и властвуй".
Возвращаясь  к прошлому уроку, какой будет базовый случай у данного алгоритма? Напоминаю, что базовый случай - это простой случай, когда мы знаем что делать. Из входных данных у нас только массив, который надо отсортировать.

Ответ: массив длиной меньше двух элементов, то есть пустой массив и  массив из одного элемента. Когда входными данными являются они, **нам не нужно ничего сортировать**. Поэтому это и есть простой, базовый случай для нашего алгоритма.

С базовым случаем разобрались. Теперь необходимо понять рекурсивный случай. Рекурсивный случай должен нас приближать к базовому случаю. Как раз-таки разделение массива на две части и будет нас приближать к нему.

Слегка изменяя аналогию с картами, получаем следующий алгоритм сортировки:
1. Если длина массива < 2, то просто возвращаем массив.
2. Иначе делим массив пополам (если количество элементов чётное) либо же на почти две равные половины.
3. Сортируем левую и правую часть.
4. Получаем итоговый массив, постепенно добавляю элементы левого и правого отсортированных подмассивов в нужном порядке.

Перед реализацией проверим истинность нашего рекурсивного случая.
Пусть приходит такой массив: `[10, 5]`. Длина этого массива большего одного. Надо сортировать. Согласно алгоритму делим поровну по середине: `[10]` и `[5]`. Каждый из этих подмассивов надо отсортировать вызовом нашей же функции - рекурсией. 

Длина этих массивов - один элемент. А с одним элементом наша функция легко справляется, ведь это базовый случай. Получается, что с двумя элементами наш алгоритм рекурсивно приводит к базовому случаю.

Теперь возьмем массив из трёх элементов: `[120, 34, 57]`. Делим на две почти ровных части: `[120, 34]` и `[57]`. Мы уже проверили, что с двумя элементами наша функция работает, как и с одним. В итоге, с тремя элементами в массиве наш алгоритм также рекурсивно приводит к базовому случаю.

## Реализация алгоритма.
Базовый случай:
```python
def merge_sort(arr: list):
    if len(arr) <= 1:
        return arr
    # Рекурсивный случай снизу...
```

Рекурсивный случай:
```python
def merge_sort(arr: list):
    # Базовый случай
    ...
    middle = len(arr) // 2 # Определяем середину массива

    sorted_left = merge_sort(arr[:middle]) # Сортируем левую часть
    sorted_right = merge_sort(arr[middle:]) # Сортируем правую часть

	return merge(sorted_left, sorted_right)
```

Логику получения сортированного массива из двух отсортированных я вынес в функцию `merge`:

```python
def merge(left: list, right: list):
    sorted_arr = [] # результативный массив
    left_idx, right_idx = 0, 0
    left_length = len(left)
    right_length = len(right)

	# Пока мы не прошлись хотя бы по одному из массивов
    while left_idx < left_length and right_idx < right_length:
        if left[left_idx] <= right[right_idx]: #Если элемент левого массива <= элементу правого массива
            sorted_arr.append(left[left_idx]) # то добавляем его
            left_idx += 1 # и рассматриваем следующий элемент левогом массива
        else:
            sorted_arr.append(right[right_idx])
            right_idx += 1 # иначе правого

	# Если же правый массив закончился раньше:
    while left_idx < left_length:
        sorted_arr.append(left[left_idx])
        left_idx += 1
        #добавляем все оставшиеся элементы левого массива

    while right_idx < right_length:
        sorted_arr.append(right[right_idx])
        right_idx += 1
        #добавляем все оставшиеся элементы правого массива

    return sorted_arr

```


Вся реализация:
```python
def merge(left: list, right: list):
    sorted_arr = []
    left_idx, right_idx = 0, 0
    left_length = len(left)
    right_length = len(right)

    while left_idx < left_length and right_idx < right_length:
        if left[left_idx] <= right[right_idx]:
            sorted_arr.append(left[left_idx])
            left_idx += 1
        else:
            sorted_arr.append(right[right_idx])
            right_idx += 1

    while left_idx < left_length:
        sorted_arr.append(left[left_idx])
        left_idx += 1

    while right_idx < right_length:
        sorted_arr.append(right[right_idx])
        right_idx += 1

    return sorted_arr

def merge_sort(arr: list):
    if len(arr) <= 1:
        return arr

    middle = len(arr) // 2
    sorted_left = merge_sort(arr[:middle])
    sorted_right = merge_sort(arr[middle:])

    return merge(sorted_left, sorted_right)
```
## На примере

Рассмотрим пошаговое выполнение функции `merge` на конкретном примере.

```python
left = [3, 7, 10]   # Уже отсортированный массив
right = [2, 5, 9]   # Уже отсортированный массив
result = merge(left, right)
```


| Шаг | left_idx | right_idx | Сравнение           | sorted_arr          |
|-----|----------|-----------|---------------------|---------------------|
| 1   | 0        | 0         | 3 <= 2? Нет → 2     | [2]                 |
| 2   | 0        | 1         | 3 <= 5? Да → 3      | [2, 3]              |
| 3   | 1        | 1         | 7 <= 5? Нет → 5     | [2, 3, 5]           |
| 4   | 1        | 2         | 7 <= 9? Да → 7      | [2, 3, 5, 7]        |
| 5   | 2        | 2         | 10 <= 9? Нет → 9    | [2, 3, 5, 7, 9]     |
| 6   | 2        | 3         | Остаток left → 10   | [2, 3, 5, 7, 9, 10] |

## Big O Merge sort
- **Пространственная сложность**: O(n). В функции `merge` итоговый массив `sorted_arr` хранит n элементов
- **Временная сложность**: O(n log n) во всех случаях.
	- Сама функция `merge` выполняется за O(n) - внутри только последовательные циклы, а не вложенные, поэтому константа отбрасывается.
	- Однако из-за рекурсия функция `merge` вызывается O(log n) раз.

