# Что такое пузырьковая сортировка?

**Bubble Sort (пузырьковая сортировка)** — это алгоритм сортировки, который последовательно сравнивает соседние элементы массива и меняет их местами, если они находятся в неправильном порядке. Процесс повторяется, пока массив не будет отсортирован.

Представьте, что вы сортируете стопку монет по возрастанию. Вы проходите по стопке, сравниваете каждую пару соседних монет и меняете их местами, если большая монета лежит выше меньшей. Так вы постепенно "всплываете" самые крупные монеты вверх.

## Реализация пузырьковой сортировки

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        for j in range(n - 1 - i):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
```

### Объяснение

Основу пузырьковой сортировки составляет сравнение двух соседних элементов. Если `arr[i] > arr[i + 1]`, то мы меняем их местами, так как больший элемент должен идти после меньшего. Иначе ничего не делаем. Затем переходим к следующим соседним элементам.

Возьмём массив `[5, 3, 8, 4, 2]` и пройдем по нему согласно алгоритму:

1. `[5, 3, 8, 4, 2]` → 5 > 3? Да → меняем местами → `[3, 5, 8, 4, 2]`
2. `[3, 5, 8, 4, 2]` → 5 > 8? Нет → оставляем как есть
3. `[3, 5, 8, 4, 2]` → 8 > 4? Да → меняем местами → `[3, 5, 4, 8, 2]`
4. `[3, 5, 4, 8, 2]` → 8 > 2? Да → меняем местами → `[3, 5, 4, 2, 8]`

В итоге самый большой элемент — 8 — "всплыл" на своё место в конце массива. Отсюда название "пузырьковая сортировка".

Однако массив не отсортирован полностью — для этого нужно повторить процесс несколько раз. За один проход мы гарантированно ставим на место только один элемент. Значит, проходы надо повторять `n - 1` раз.

Например, для массива `[3, 2, 1]` после первого прохода самый большой элемент окажется в конце, затем второй проход упорядочит оставшуюся часть.

Поэтому алгоритм использует два цикла:

```python
for i in range(n - 1):
    for j in range(n - 1 - i):
        ...
```

Внутренний цикл сравнивает соседние элементы, а внешний повторяет этот процесс `n - 1` раз.

Почему внутренний цикл до `n - 1 - i`?

Мы сравниваем пары элементов с индексами `j` и `j + 1`, поэтому нельзя выходить за пределы массива. Если пройти до `n`, то на последней итерации `j + 1` выйдет за границы.

Кроме того, после каждого полного прохода самый большой элемент оказывается в конце массива, и на следующем проходе можно не трогать уже отсортированную часть. Отсюда вычитается `i` — номер текущей итерации внешнего цикла.

## Big O

Временная сложность пузырьковой сортировки в худшем и среднем случае — **O(n²)**.

Даже в лучшем случае (когда массив уже отсортирован) обычный вариант без оптимизации будет иметь сложность **O(n²)**, так как циклы все равно выполнятся полностью.

Можно улучшить алгоритм, добавив проверку, был ли произведён обмен за проход. Если обменов не было, массив уже отсортирован и алгоритм может завершиться раньше.

### Оптимизированная версия с проверкой:

```python
def bubble_sort_optimized(arr):
    n = len(arr)
    for i in range(n - 1):
        swapped = False  # был ли обмен?
        for j in range(n - 1 - i):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        if not swapped:
            break  # массив отсортирован, заканчиваем
    return arr
```

В лучшем случае (если массив уже отсортирован) оптимизированный вариант будет работать за **O(n)** — один проход внутреннего цикла.

## Когда использовать?

* Для обучения — из-за простоты реализации.
* Для небольших массивов — из-за квадратичной сложности.
* В реальных проектах почти не применяется, поскольку существуют более эффективные алгоритмы, такие как QuickSort или Merge Sort.

## Заключение

Пузырьковая сортировка — хороший алгоритм для начала изучения сортировок, но на практике она неэффективна для больших данных.
