
# Что такое пузырьковая сортировка?**  
**Bubble Sort (пузырьковая сортировка)** - это алгоритм сортировки, который последовательно сравнивает соседние элементы массива и меняет их местами, если они находятся в неправильном порядке. Процесс повторяется, пока массив не будет отсортирован.  
  
Представьте, что вы сортируете стопку монет по возрастанию. Вы проходите по стопке, сравниваете каждую пару соседних монет и меняете их местами, если большая монета лежит выше меньшей. Так вы постепенно "всплываете" самые крупные монеты вверх.  
## Реализация пузырьковой сортировки
```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):  
        for j in range(n - 1 - i):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
```

### Объяснение
Все познается на примерах. 

**Основа пузырьковой сортировки - это сравнение двух соседних элементов.** Если `arr[i]` > `arr[i + 1]`,  то нас это не устраивает (ведь больший элемент должен стоять в массиве после меньшего, а не наоборот) и мы меняем их значения местами. Иначе мы ничего не делаем. После чего мы переходим к следующим двум соседним элементам.

Возьмём массив из 5 чисел: `[5, 3, 8, 4, 2]`. И пройдемся массиву согласно алгоритму выше. 

Сравниваем попарно все элементы:

1. `[5, 3, 8, 4, 2]` → **5 > 3**? Да → Меняем местами → `[3, 5, 8, 4, 2]`  
2. `[3, 5, 8, 4, 2]` → **5 > 8**? Нет → Оставляем как есть  
3. `[3, 5, 8, 4, 2]` → **8 > 4**? Да → Меняем местами → `[3, 5, 4, 8, 2]`  
4. `[3, 5, 4, 8, 2]` → **8 > 2**? Да → Меняем местами → `[3, 5, 4, 2, 8]`  

После выполнения действий получаем следующий результат: `[3, 5, 4, 2, 8]`. Как видим, самый максимальный элемент - 8 - оказался на своем месте, в самом конце. Он "всплыл" наверх. Отсюда и название пузырьковая сортировка.

Однако стал ли массив от этого отсортированным? Нет. За один проход мы поставили на свое место только один элемент. А у нас еще n - 1 элементов. Получается, наши проходы надо повторять столько раз, сколько элементов в массиве? Да, можно и так сказать - n раз. Однако правильнее всего будет n - 1 раз. 

Дело в том, что самый минимальный элемент будет уже стоять на своем месте. Проверьте сами на массиве `[3, 2, 1]`. Пройдитесь и поставьте на правильное место сначала `3`, затем `2`. И вот `1` стоит уже на своем месте.

Из-за этого алгоритм использует два цикла:
```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):  
        for j in range(n - 1 - i):
	        ...
```

Внутренний цикл используется для сравнения соседних элементов.
А внешний для повторения того же процесса n - 1 раз.

Если с внешним стало понятно, то в чем смысл `n - 1 - i` во внутреннем цикле?

Не стоит забывать, что проходя по массиву мы работаем с индексами, и мы не должны выходить за пределы массива.

```python
for j in range(n - 1 - i):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
```

Внутри массива мы берем `j` и `j + 1`.  Представим, что в нашем цикле вместо `n - 1 - i` мы бы проходились до `n`. Пусть n - размер массива - будет 5. Тогда максимальный индекс для данного массива будет 4.
В теле цикла, когда `j` будет равняться 4-м, `j + 1` даст 5. Но пять выходит за пределы массива! А все из-за того, что в теле цикла мы берем два элемента. И так на каждой итерации. 

Поэтому мы должны пройтись не `n` раз, а `n - 1` раз. Мы ведь работаем с парами соседних элементов. Так мы избавимся от ошибки превышения индекса. 

Теперь `n - 1` во внутреннем цикле стало понятнее. Но что насчет `i`? Его ведь я тоже пишу в `n - 1 - i`.

Каждый раз, повторяя внутренний цикл, мы ставим один элемент на свое правильное место где-то в конце. И больше его не придется менять. Поэтому можно проверять уже на один элемент меньше. Затем на два элемента меньше, на три.

За количество проходов у нас отвечает внешний цикл. Чтобы слегка оптимизировать алгоритм, мы как-раз таки берем номер итерации `i` и вычитаем его для нахождения максимального индекса, до которого есть смысл проходить. Отсюда и получается запись `n - i - 1`.


## Big O
Временная сложность пузырьковой сортировки составляет в худшем случае O(n<sup>2</sup>).

Да и для лучшего случая (когда массив уже отсортирован) она также будет O(n<sup>2</sup>): мы ведь не проверяем что массив отсортирован, циклы будут запускаться, лишь не будет происходить обмен элементов.

Поэтому можно оптимизировать до некоторой степени bubble sort. После каждого прохода внутреннего цикла проверять, не был ли произведен обмен элементов. Если же не было, то все элементы уже стояли на своих местах. Тогда сортировку можно заканчивать.

**Оптимизированная версия (с проверкой на отсортированность):**  
```python
def bubble_sort_optimized(arr):
    n = len(arr)
    for i in range(n - 1):
        swapped = False # Переменная со смыслом: обмен был?
        for j in range(n - 1 - i):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True # да, обмен был
        if not swapped:  # Если обменов не было, массив отсортирован
            break # заканчиваем работу сортировки
    return arr
```  

Используя такую проверку, для лучшего случая временная сложность станет O(n): нам все равно придется сделать один проход по циклу, чтобы понять отсортирован массив или нет.

## Когда использовать?
- Для обучения (из-за простоты реализации).  
- На небольших массивах - из-за O(n²).  
- В реальных проектах почти не применяется (есть более эффективные алгоритмы, например, `QuickSort` или `Merge Sort` в Python).  

## Заключение
Bubble Sort - это неплохой алгоритм для небольших массивов. На практике он почти не применяется. Но для начала обучения сортировкам он в самый раз.