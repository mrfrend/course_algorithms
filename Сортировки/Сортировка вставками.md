# Что такое сортировка вставками?**  
**Сортировка вставками (Insertion Sort)** - алгоритм сортировки, который на каждом шаге берет очередной элемент и вставляет его в правильную позицию в уже отсортированной части массива.  

Представьте, что вы сортируете игральные карты в руке. Вы держите несколько карт отсортированными, а новые карты вставляете в нужное место, сравнивая их с уже имеющимися.  

## Реализация
```python
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]массива 
        j = i - 1 
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr
```

## Объяснение 

1. **Разделение массива**: массив делится на отсортированную (слева) и неотсортированную (справа) части.  
2. **Выбор элемента**: берется **первый элемент** из неотсортированной части.  
3. **Поиск позиции**: **элемент сравнивается с элементами отсортированной части** справа налево, чтобы найти правильную позицию.  
4. **Вставка**: элемент вставляется в найденную позицию, остальные элементы сдвигаются.  
5. **Расширение отсортированной части**: граница сдвигается вправо. 

Для визуализации алгоритма рекомендую посмотреть следующий ролик - https://www.youtube.com/watch?v=a4IQKxDyR6s

Изначально мы предполагаем, что отсортированная часть массива уже есть и она состоит из одного элемента - самого первого. Поэтому наша неотсортированная часть массива начинается с 1, отсюда и `for i in range(1, len(arr))`.

`j` в цикле устанавливает последний индекс отсортированной части массива: `i - 1`, ведь `i` каждый раз указывает на первым элемент неотсортированной части массива.

Цикл while позволяет нам найти место для вставки. Пока мы его ищем в отсортированной части массива, все элементы сдвигаются на один вправо.

После нахождения позиции (`j`) ставим на нее нам элемент из неотсортированной части массива.

## Big O 
  - Временная сложность:
	  - Лучший случай (уже отсортированный массив): **O(n)**  
	  - Средний и худший случаи: **O(n²)**  
- Пространственная сложность : **O(1)** (сортировка на месте)  


## Когда использовать?  
- На небольших или частично отсортированных массивах.  
- В реальных приложениях, например, когда новые данные поступают последовательно и их нужно поддерживать в отсортированном виде.  
