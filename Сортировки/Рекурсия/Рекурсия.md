Следующие два алгоритма сортировки (Quick Sort и Merge Sort) будут использовать рекурсию, поэтому нам необходимо заранее узнать что этою

# Что такое рекурсия?  
**Рекурсия** — это подход в программировании, при **котором функция вызывает саму себя для решения задачи**, разбивая ее на более простые подзадачи того же типа.

Представьте матрешку: чтобы добраться до самой маленькой куклы, нужно последовательно открывать каждую большую. Последняя матрешка (базовый случай) не содержит внутри ничего, и процесс завершается.  

**Еще раз: функция вызывает саму себя для решения задачи.**

Однако матрёшка рано или поздно заканчивается. Мы не можем до бесконечности открывать снова и снова новую матрешку внутри.

То же самое и вызовами функции - у нас просто закончится память. Почему у нас закончится память? Все дело в *стеке вызовов*.

## Стек вызовов.
**Стек вызовов (Call Stack)** — это структура данных в программировании, которая используется для хранения информации **о вызове функций во время выполнения программы**.

В стеке вызовов хранятся значение переданных аргументов функции, адрес возврата инструкции (на чем надо продолжить, если была вызвана внутри еще другая функция) и так далее.

**Стек вызовов помогает отслеживать порядок выполнения функций**.

Рассмотрим на примере:

```python
def third():
    print('third')

def second():
    print('second')
    third()
    
def first():
    print('first')
    second()
    
first()
```

Мы вызываем функцию `first()`, которая вызывает внутри себя функцию `second()`, которая в свою очередь вызывает функцию `third()`.

Рассмотрим пошаговое выполнение кода с точки зрения стека вызова:

1. Вызывается `first()` → добавляется в стек.  
    **Стек:** `[first]`  
    Вывод: `"first"`
    
2. `first` вызывает `second()` → `second` добавляется в стек.  
    **Стек:** `[first, second]`  
    Вывод: `"Second"`
    
3. `second` вызывает `third()` → `third` добавляется в стек.  
    **Стек:** `[first, second, third]`  
    Вывод: `"Third"`
    
4. `third` завершается → удаляется из стека.  
    **Стек:** `[first, second]`
    
5. `second` завершается → удаляется из стека.  
    **Стек:** `[first]`
    
6. `first` завершается → стек становится пустым.  
    **Стек:** `[]`

Ничего не напоминает? Ладно, подсказка в самом названии - **стек вызовов это и есть стек**. И работает он по тому же принципу **LIFO**.
Такая работа с данными позволяет накапливать функции, а затем удалять их сверху. В результате мы получаем правильную последовательность вызовов и работы функций.

Теперь понятно, почему нельзя бесконечно вызывать функции - стек вызовов переполнится. Но как этого избегать? Это решает сама рекурсия.

Рекурсивная функция состоит из двух частей:  
1. **Базовый случай** — условие выхода из рекурсии (остановка).  
2. **Рекурсивный случай** — вызов функции с упрощенной версией задачи.  

**Базовый случай - это простой случай, когда мы знаем что делать**, из-за чего нам не нужно вызывать саму функцию с другими значениями параметров. Этот базовый случай и останавливает бесконечный вызов. Опять же рассмотрим на примере.

## Пример рекурсии на факториале числа
**Факториал числа n** - это произведение чисел от 1 до n включительно. Обозначается восклицательным знаком. К примеру, 3! = 1 \* 2 \* 3 = 6.

Хоть я и сказал определение факториала, для 0! = 1. Что-то связано с комбинаторикой, можете почитать об этом.

Факториал числа можно узнать через факториал другого числа. Видите повторение? Это знак к рекурсии.

Что я имею в виду?

4! = 1 \* 2 \* 3 \* 4. Ранее я сказал, что факториал - это последовательность умножений чисел.
А ведь 1 \* 2 \* 3 мы можем записать по-другому, как 3!, не так ли?

Получается, 4! = 1 \* 2 \* 3 \* 4 = **3! \* 4**. Мы получили факториал 4 через умножение факториала 3-х на 4.

И то же самое будет с другими факториалами, кроме нулевого. Попробуйте.

В общем, другую формулу для нахождения факториала числа n можно записать так:
n! = (n - 1)! \* n
4! = **3! \* 4**

Давайте запишем это в виде функции для нахождения факториала:

```python
def factorial(n):
    return n * factorial(n - 1) # согласно формуле рекурсивный случай
```

Но пока функция не будет правильно работать. У нас получается бесконечный вызов. Необходимо определить базовый случай, который закончит бесконечный вызов функции самой себя.

А какой самый базовый случай у нас будет для этой задачи? Когда мы точно знаем чему равен факториал? Это факториал нуля. Он исключение из правил, а также граница когда надо заканчивать рекурсию - у нас нет факториалов отрицательного числа.

Допишем базовый случай.
```python
def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n - 1)
```

Теперь наша функция готова к работе. Запустите ее с различными значениями аргумента и сравните правильность результата.

При работе с рекурсиями рекомендую использовать сайты для визуализации вызовов функции. Например, https://recursion.vercel.app/. Правда, только для python, node и Golang.

Разберём пошагово, как работает стек вызовов при вычислении `factorial(3)` в Python.

**Рекурсивный вызов `factorial(3)`**

```python
def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n - 1)
```

**Первый вызов: `factorial(3)`**
- Условие `n == 0` → `False` → идём в `return 3 * factorial(2)`  
- **Стек:**  
  ```
  factorial(3)  # ожидает factorial(2)
  ```

**Второй вызов: `factorial(2)`**
- Условие `n == 0` → `False` → `return 2 * factorial(1)`  
- **Стек:**  
  ```
  factorial(2)  # ожидает factorial(1)
  factorial(3)  # ожидает factorial(2)
  ```

**Третий вызов: `factorial(1)`**
- Условие `n == 0` → `False` → `return 1 * factorial(0)`  
- **Стек:**  
  ```
  factorial(1)  # ожидает factorial(0)
  factorial(2)  # ожидает factorial(1)
  factorial(3)  # ожидает factorial(2)
  ```

**Четвёртый вызов: `factorial(0)`**
- Условие `n == 0` → `True` → возвращает `1`  
- **Стек начинает "разворачиваться":**  

  ```
  factorial(1)  # получил factorial(0) = 1 → возвращает 1 * 1 = 1
  factorial(2)  # ожидает factorial(1)
  factorial(3)  # ожидает factorial(2)
  ```

**Возврат из `factorial(1)`**
- `factorial(1)` вернул `1` → теперь `factorial(2)` может вычислиться:  
  `return 2 * factorial(1) = 2 * 1 = 2`  
- **Стек:**  
  ```
  factorial(2)  # вернул 2
  factorial(3)  # ожидает factorial(2)
  ```

**Возврат из `factorial(2)`**
- `factorial(2)` вернул `2` → теперь `factorial(3)` может вычислиться:  
  `return 3 * factorial(2) = 3 * 2 = 6`  
- **Стек:**  
  ```
  factorial(3)  # вернул 6
  ```

**Финальный результат**
- `factorial(3)` возвращает `6` → стек пуст.  

| Шаг | Вызов          | Действие                          | Стек (сверху вниз)          |
|-----|----------------|-----------------------------------|-----------------------------|
| 1   | `factorial(3)` | `3 * factorial(2)`                | `[factorial(3)]`            |
| 2   | `factorial(2)` | `2 * factorial(1)`                | `[factorial(2), factorial(3)]` |
| 3   | `factorial(1)` | `1 * factorial(0)`                | `[factorial(1), factorial(2), factorial(3)]` |
| 4   | `factorial(0)` | Возвращает `1`                    | Стек начинает "схлопываться" |
| 5   | `factorial(1)` | `1 * 1 = 1` → возвращает `1`      | `[factorial(2), factorial(3)]` |
| 6   | `factorial(2)` | `2 * 1 = 2` → возвращает `2`      | `[factorial(3)]`            |
| 7   | `factorial(3)` | `3 * 2 = 6` → возвращает `6`      | `[]` (стек пуст)            |

**Что возвращается на каждом шаге?**
1. `factorial(0)` → `1`  
2. `factorial(1)` → `1 * 1 = 1`  
3. `factorial(2)` → `2 * 1 = 2`  
4. `factorial(3)` → `3 * 2 = 6`  

**Итоговый ответ:** `6`  

```
factorial(3)
│
└─ 3 * factorial(2)
      │
      └─ 2 * factorial(1)
            │
            └─ 1 * factorial(0)
                  │
                  └─ 1  # база рекурсии
```

## Итерация vs Рекурсия  
Данную задачу можно было решить через обычный цикл. Более того, решение на циклах намного производительнее в данном случае, так не тратятся зарплаты на сохранение в памяти вызова новой функции.

Любое решение через рекурсию можно переписать на циклы. И наоборот.

Есть одна цитата от Ли Колдуэлла с сайта Stack Overlow: "*Циклы могут ускорить работу программы. Рекурсия может ускорить работу программиста. Выбирайте, что важнее в вашей ситуации!".

Выбирайте, что вам важнее.

## Заключение
- Рекурсия — мощный инструмент в программировании, позволяющий элегантно решать задачи, которые естественным образом распадаются на более мелкие подзадачи того же типа.  
- Функция вызывает саму себя, пока не достигнет **базового случая**.
- **Базовый случай** — условие выхода из рекурсии
- **Рекурсивный случай** — вызов функции с упрощенной задачей (например, `factorial(n-1)`).  
- Рекурсия использует стек для хранения состояний каждого вызова.  
- Без базового случая приводит к **переполнению стека (Stack Overflow)**.  
- **Рекурсия** — лаконичный код, удобен для задач с вложенностью (деревья, графы).  
- **Итерация** (циклы) — меньше накладных расходов, лучше для линейных вычислений.  