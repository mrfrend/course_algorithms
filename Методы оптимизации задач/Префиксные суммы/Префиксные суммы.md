**Префиксные суммы** (они же **частичные суммы**, **cumulative sums**) — это структура, которая позволяет быстро вычислять сумму элементов массива на любом отрезке.

## Пример задачи с префиксной суммой
Представьте, что вы - ютубер. И вы хотите получать или же рассчитывать **счёт видео** - количество лайков вычесть количество дизлайков - к определенному дню после загрузки видео.

И вот вы храните результаты счёта видео за каждый день в массиве:
```python
[8, 3, -2, 4, 10, -1, 0, 5, 3]
```

Как видите, в первый день - в день загрузки видео - счёт был 8 (количество лайков - количество дизлайков). Во второй день 3, в третий -2 (уже понасыпали дизлайков). И так далее

Но данные остаются просто данными. Лучше использовать их для ответов на вопросы. Нас, как ютубера, интересует ответ на вопрос ***"А как хорошо моё видео показало с n дня по m день?"***

Как это посчитать через код? Просто посчитать **сумму** от позиции n в массиве до позиции m включительно:

```python
scores = [8, 3, -2, 4, 10, -1, 0, 5, 3]
def get_video_performance(start_day: int, end_day: int):
	performance = 0
	for i in range(start_day, end_day + 1):
		performance += scores[i]
	return performance
```

Такой алгоритм работает за O(n) - линейная сложность.

А что, если был бы сервис, позволяющий получать ответы на такие вопросы? Нужно учитывать, что время с выхода видео растет и растет, а значит и проходить нужно по большему количеству дней. А запросы пользователей? Их будет много, и вот уже O(n) не особо нас радует. Конечно, можно оставить и так, но зачем, ведь можно быстрее, при этом всё также понятно.

**Префиксные задачи используют в алгоритмах связанных с накоплением**, в нашем случае с общим счетом (суммой) видео за определенный отрезок дней.

## Оптимизируем решение
Идея префиксной суммы такая:
**Вычислить массив, где каждый элемент — сумма всех предыдущих элементов.**
```python
prefix[i]=a[0]+a[1]+⋯+a[i]
```

Следующий код создает префиксный массив для переданного массива:

```python
def prefix_sums(arr):
    n = len(arr)
    prefix = [0] * n
    prefix[0] = arr[0]
    for i in range(1, n):
        prefix[i] = prefix[i - 1] + arr[i]
    return prefix
```

Это лишь подготовка - она выполняется за O(n).

Теперь мы узнаем как выполнять запросы, связанные с суммой, за O(1).

Наша нынешняя задача сводится к тому, чтобы найти сумму элементов массива от n до m включительно, где n <= m < length.

Для примера, пусть нам необходимо вычислить сумму элементов массив от позиции 2 до позиции 5 включительно. Воспользуемся нашим созданным префиксным массивом!

prefix[5] содержит себе сумму элементов от 0 до 5: a0 + a1 + a2 + a3 + a4 + a5.
Нам же нужно получить a2 + a3 + a4 + a5. Что для этого нужно сделать? Вычесть a0 и a1. А где хранится их сумма? В prefix[1].

Получается, ответ на нашу задачу в данном случае есть ничто иное как разность между prefix[5] и prefix[1].

Получается, задача решается следующим общим способом: **prefix[r] - prefix[l - 1]**, где l, r - позиции в массиве, l <= r.

### Особый случай
А что делать, если нас попросят найти суммы от начала ( с нулевой позиции) до r? Если от нуля вычесть один, как в формуле, то мы получим индекс -1. Python поддерживает отрицательные индексы, поэтому программа продолжит работать, но выдаст неправильный результат.

Пример: l = 0, r = 4. Результат: prefix[4] - prefix[0 - 1] = prefix[4] - prefix[-1].

Тогда мы можем проверять, что если мы хотим посчитать сумму с начала (l = 0), то мы просто возвращаем prefix[r].

Более же элегантным решением является сместить все вычисления в префиксном массиве на один в право, т.е. начинать создание и заполнение префиксного массива с первой позиции:

```python
def prefix_sums(arr):
    n = len(arr)
    prefix = [0] * (n + 1) # теперь размер префиксного массива на один больше
    for i in range(1, n + 1):
        prefix[i] = prefix[i - 1] + arr[i - 1]
    return prefix
```

Теперь, prefix[2] будет содержать только сумму a0 + a1, а не a0 + a1 + a2 как раньше.

И наша формула преобразуется в следующую: 
prefix[r] - prefix[l - 1] = prefix[r + 1] - prefix[l]

Теперь, если будут запросы вида суммы от 0 до r, мы будем получать такой ответ: prefix[r + 1] - prefix[0] = prefix[r + 1] - 0 = prefix[r + 1]
