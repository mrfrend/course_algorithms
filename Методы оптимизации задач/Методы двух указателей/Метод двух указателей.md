## Что это такое?
**Метод двух указателей** — это способ итерации по массиву с использованием двух переменных (указателей), которые перемещаются по массиву независимо или синхронно, чтобы найти нужный результат эффективнее, чем грубой силой (brute force).

## Вариации
1. **Сходящиеся указатели**. Два указатели изначально указывают на начало и конец последовательной структуры данных. Затем приближаются друг другу до тех пор, пока условие не удовлетворено, либо пока они не встретятся (станут указывать на одну позицию примерно в середине).
2. **Параллельные указатели**. Начинают с одной позиции, а затем поддерживают расстояние (разность) между указателями.
3. **Триггерные указатели**. В данном случае имеется fast-указатель, который проходит независимо от другого указателя slow, до тех пор пока не выполнится требуемое условие. Затем slow указатель также начинает независимо двигаться и останавливается, когда выполняется другое условие.

## Когда используется метод двух указателей?
- Массив **отсортирован** (часто, но не обязательно)
- Нужно найти **пару**, **сумму**, **пересечения**, **дубликаты**, **подотрезки**
- Требуется решение за **линейное или квазилинейное** время, а не квадратичное

## Типичные задачки

### **Поиск двух чисел с заданной суммой**

**Условие:** Найти, есть ли в отсортированном массиве пара чисел, сумма которых равна `target`. Если есть, то вернуть индексы этих элементов

```python
def two_sum_sorted(nums, target):
    left, right = 0, len(nums) - 1
    while left < right:
        curr_sum = nums[left] + nums[right]
        if curr_sum == target:
            return [left, right]
        elif curr_sum < target:
            left += 1
        else:
            right -= 1
    return []
```

### **Удаление дубликатов в отсортированном массиве**

```python
def remove_duplicates(nums):
    if not nums:
        return 0
    write = 1
    for read in range(1, len(nums)):
        if nums[read] != nums[read - 1]:
            nums[write] = nums[read]
            write += 1
    return write
```

Один указатель читает (`read`), другой пишет (`write`)

### **Скользящее окно (вариация)**

**Пример:** Найти наибольшую длину подмассива без повторяющихся символов (в строке)

```python
def length_of_longest_substring(s):
    seen = set()
    left = 0
    max_len = 0

    for right in range(len(s)):
        while s[right] in seen:
            seen.remove(s[left])
            left += 1
        seen.add(s[right])
        max_len = max(max_len, right - left + 1)
    return max_len
```
