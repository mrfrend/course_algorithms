# Оценка алгоритмов

Одну и ту же задачу можно решить разными способами. Чтобы выбрать наилучший, нужно оценить эффективность алгоритма.

## Критерии оценки алгоритмов

1. **Временная сложность** — как быстро работает алгоритм (зависимость от размера входных данных).
2. **Пространственная сложность** — сколько памяти потребляет алгоритм при выполнении.

---

## Временная сложность

Временная сложность показывает, сколько операций выполняет алгоритм при обработке входных данных размером *n*.

### Пример:
```python
def count_even(numbers: list[int]):
    count = 0
    for num in numbers:
        if num % 2 == 0:
            count += 1
    return count
```

#### Какие операции считаем?
- Арифметические (`+`, `%`, и т. п.)
- Сравнения (`==`, `<`, и т. д.)
- Присваивания (`x = y`)
- Доступ к данным (чтение/запись переменных, элементов списка)
- Логические операции (`and`, `or`, `not`)

Для оценки вводим модель **RAM-машины**:
- Память неограниченна
- Все операции выполняются за одинаковое фиксированное время

#### Подсчёт операций на примере `[2, 4, 6, 8, 10]`:
1. `count = 0` — 1 операция  
2. `for num in numbers` — 5 присваиваний (по числу элементов)  
3. `if num % 2 == 0` — 3 операции (чтение, деление, сравнение)  
4. `count += 1` — 2 операции  
5. `return count` — 1 операция

Операции внутри цикла повторяются *n* раз (в нашем случае — 5):

```
T(n) = 1 + n * (3 + 2) + 1 = 2 + 5n
```

---

## Случаи временной сложности

- **Лучший случай** — минимальное число операций (например, если все числа нечётные)
- **Худший случай** — максимальное число операций (все числа чётные)
- **Средний случай** — усреднённая оценка (в практике используется реже)

**Оценивайте по худшему случаю!** Это надёжный ориентир.

---

## Big O-нотация

Big O показывает, как быстро растёт количество операций в зависимости от *n* — размера входа.

### Упрощение Big O:
1. **Игнорируем константы** → `O(5n)` → `O(n)`
2. **Берём только самую быстрорастущую часть** → `O(n² + n)` → `O(n²)`
3. **Разные входы — разные переменные** → `O(n + m)` остаётся
4. **Вложенные циклы** → умножаем сложности: `O(n * m)`
5. **Последовательные операции** → выбираем наибольшую: `O(n log n + n)` → `O(n log n)`

#### Пример:
```
T(n) = 2 + 5n → O(n)
```

Это **линейный алгоритм**, сложность растёт пропорционально размеру входных данных.

---

## Пространственная сложность

Показывает, сколько памяти нужно алгоритму.

В примере выше:
- Используется одна переменная `count`, которая не зависит от входных данных
- Значит, **O(1)** — константная сложность

Если же память зависит от *n*, например, создаётся новый список, массив и т.д., то это уже **O(n)**, **O(n²)** и т.п.

---

## Вывод

- Сравнивайте алгоритмы по **времени** и **памяти**
- Оценивайте по **худшему случаю**
- Упрощайте выражения через Big O
- Не забывайте: простая формула → мощный инструмент анализа
