# Что такое бинарная куча?
**Бинарная куча (Binary Heap)** - это тип бинарного дерева, позволяющий получить самый минимальный / максимальный узел дерева.

Возможно, некоторые распределяли расположение книг в полке по приоритету книги: самые важные и часто используемые находятся ближе всего, под рукой. И так по **приоритету** располагаем. Бинарная куча — это **особая древовидная структура**, которая помогает делать это эффективно!

## Какие бывают бинарные кучи?
- Max-heap. В такой куче каждый узел >=  своим потомкам.
```python
      1
    /   \
   3     2
  / \   /
 5   4 6
```
- Min-heap. Наоборот, каждый узел <= своим потомкам.
```python
      9
    /   \
   7     5
  / \   /
 4   3 2
```

### Для чего используют?
Max-heap используется при heapsort - алгоритма сортировки, работающим за O(n logn). 

Min-heap используют для реализацию ***очереди с приоритетом***: мы храним не только элемент, а также назначенный ему приоритет (или же важность). По этой важности происходит сортировка кучи таким образом, что корнем кучи будет являться элемент с наименьшим приоритетом.

## Свойства бинарной кучи
- Корнем кучи является наименьший/наибольший элемент
- Каждый узел в max-heap (min-heap) больше (меньше) его детей.
- У каждого узла может быть максимум 2 ребёнка.
- Высота дерева бинарной кучи O(logn) - следствие свойства ниже.
- Куча является практически *полным бинарным деревом*.

Под **практически полным бинарным деревом** я подразумеваю, что:
- Все уровни кучи заполнены, кроме последнего
- Последний уровень кучи заполнен **неполностью**. Заполняется он **последовательно, слева направо**. 

Это пример практически полного бинарного дерева:

```python
	   1
	 /   \
	3     2
   /  
  4
```

На данном схематичном рисунке представлена min-heap: все потомки больше родительского узла, и дерево практически полностью заполнено.

А это пример нарушения:

```python
   1
 /   \
3     2
 \  
  4
```

Почему это ошибка? Потому что заполнение начинается слева направо. У узла `3` нет левого потомка, но есть правый — это не куча!

## Как реализуют бинарную кучу?
Бинарную кучу можно реализовать при помощи массивов, а также, как само собой разумеющиеся, при помощи бинарного дерева.

### Реализация на массиве
Массив является популярным выбором для кучи. Все благодаря тому, что куча является практически полным бинарным деревом. А где же связь?

К примеру, есть такая куча:
```python
	1
  /   \
 3     2
/ \   /
5   4 6
```

И мы можем представить ее в виде массива с таким порядком элементов: `[1, 3, 2, 5, 4, 6]`. Просто идем слева направо, по уровням.

Храня вершины кучи как элементы массива, мы имеем возможность получать его левого и правого потомка, а также и его родителя по формулам.

Так, для узла с индексом i:
- Левый потомок: `2i + 1`
- Правый потомок: `2i + 2`
- Родитель: `(i - 1) // 2`

Какой левый потомок у узла 1? Узел 3. Узел 1 хранится как первый элемент массив, т.е. индекс 0. Подставляем в формулу - `2 * 0 + 1 = 1`. Под индексом 1 находится узел 3. Правый потомок будет под индексом `2*0 + 2 = 2`.

Почему это работает? В полном бинарном дереве **все уровни полностью заполнены, кроме последнего**. В нашей куче у нас три уровня. Значит, первые два полностью заполнены. Заметили ли вы, что количество узлов на каждом уровне увеличивается вдвое? И уровни полностью заполнены. Кроме последнего, разумеется. `2i` необходимо, чтобы определить сколько уровней мы прошли. Один или два прибавляется для получения левого и правого потомка, включая еще индексацию с нуля. Поэтому дополнительно добавляется еще один.

### Min-heap
#### Вставка
Напомню, что в бинарной кучи вершины добавляются последовательно, слева направо. Но кроме этого нам необходимо удовлетворять условию, что потомки больше/меньше родительского узла.

Поэтому, после выполнения вставки вершины в конец массива, нам необходимо проверить, что узлы находятся в нужном порядке.

Реализуем MinHeap в Python. 

```python
class MinHeap:
    def __init__(self):
        self.heap = []
```

Для читаемости в дальнейшем кода, создадим методы для получения индекса левого потомка, правого, а также родителя узла. Просто повторяем формулы выше:

```python
class MinHeap:
    def __init__(self):
        self.heap = []

    def parent(self, i):
        return (i - 1) // 2

    def left_child(self, i):
        return 2 * i + 1

    def right_child(self, i):
        return 2 * i + 2
```

Теперь перейдем к самой вставке новой вершины.  Алгоритм такой:
1. Добавляем элемент в конец массива
2. При необходимо меняем порядок элементов до тех пор, пока каждый потомок не будет больше родителя.

```python
def insert(self, val):
	self.heap.append(val)
	self.heapify_up(len(self.heap) - 1)


def heapify_up(self, i):
	while i > 0 and self.heap[self.parent(i)] > self.heap[i]:
		self.heap[self.parent(i)], self.heap[i] = self.heap[i], self.heap[self.parent(i)]
		i = self.parent(i)
```

В чем смысл метода `heapify_up`? Этот метод меняет родителя и ребенка местами, если свойство для min-heap не удовлетворяется.

Код читается примерно так: `Пока мы не дошли до корня дерева (i > 0) или же пока родитель рассматриваемого узла больше его самого (нарушение свойства min-heap) - меняй их местами, и переходи к следующему узлу`

#### Удаление

Под удаление подразумевается удаление и получение минимального элемента в нашей куче. Самый минимальный элементом в min-heap всегда является корень. Однако после такой операции наше дерево остаётся без корня.

В качестве нового корня перемещается самый последний элемент в куче и становится корнем. Однако же не стоит забывать, что при любых изменениях может нарушиться свойство min-heap: наш корень может быть > своих потомков, что не так.

Поэтому после появления нового корня надо при необходимости менять родителя и ребенка местами. Это будет называться всплытием элемента вниз. Или же `heapify_down`.

Вот реализация метода удаления и получения минимального элемента в куче.

```python
def extract_min(self):
	if not self.heap: # Если куча не заполнена
		return None # то и возвращать нечего

	min_val = self.heap[0] # сохраняем наш минимум
	self.heap[0] = self.heap.pop() # Перемещаем в качестве корня наш последний элемент, а затем удаляем наш последний элемент
	self.heapify_down(len(self.heap), 0) # Используем функцию для соблюдения свойства кучи после удаления
	return min_val



def heapify_down(self, length: int, i: int):
	left_child = 2 * i + 1 
	right_child = 2 * i + 2
	smallest = i

	if left_child < length and self.heap[left_child] < self.heap[smallest]: # Если наш левый потомок меньше текущего минимального узла
		smallest = left_child

	if right_child < length and self.heap[right_child] < self.heap[smallest]: # То же самое с правым
		smallest = right_child

	if smallest != i:
		self.heap[i], self.heap[smallest] = self.heap[smallest], self.heap[i]
		self.heapify_down(length, smallest)
```

Как работает метод `heapify_down`? В контексте вызова метода `extract_min` мы начинаем с самого корня. Получаем его левого и правого потомка. А затем ищем среди них самых минимальный. 

Если минимальный узел не равняется нашему изначальному узлу (`smallest != i`, переданному в функцию, то это означает, что свойство мин-кучи было нарушено: родительский элемент был больше своих потомков. Нам необходимо поменять их местами.

После чего мы переходим на следующий уровень, вызывая функцию рекурсивно, тем самым рассматривая поддерево нашего дерева. И так до тех пор, пока свойство не будет восстановлено (т.е. `smallest == i`, и рекурсия не будет вызвана).

Полная реализация:

```python
class MinHeap:
    def __init__(self):
        self.heap = []

    def __parent(self, i):
        return (i - 1) // 2

    def __left_child(self, i):
        return 2 * i + 1

    def __right_child(self, i):
        return 2 * i + 2

    def insert(self, val):
        self.heap.append(val)
        self.__heapify_up(len(self.heap) - 1)

  
    def __heapify_up(self, i):
        while i > 0 and self.heap[self.__parent(i)] > self.heap[i]:
            self.heap[self.__parent(i)], self.heap[i] = (
                self.heap[i],
                self.heap[self.__parent(i)],
            )
            i = self.__parent(i)

    def extract_min(self):
        if not self.heap:
            return None

        min_val = self.heap[0]
        self.heap[0] = self.heap.pop()
        self.__heapify_down(len(self.heap), 0)
        return min_val

    def __heapify_down(self, length: int, i: int):
        left_child = self.__left_child(i)
        right_child = self.__right_child(i)
        smallest = i

        if left_child < length and self.heap[left_child] < self.heap[smallest]:
            smallest = left_child

        if right_child < length and self.heap[right_child] < self.heap[smallest]:
            smallest = right_child

        if smallest != i:
            self.heap[i], self.heap[smallest] = self.heap[smallest], self.heap[i]
            self.__heapify_down(length, smallest)
```

### Max-heap
Примерно такой же код для max-heap

```python
class MaxHeap:
    def __init__(self):
        self.heap = []

    def __parent(self, i):
        return (i - 1) // 2

    def __left_child(self, i):
        return 2 * i + 1

    def __right_child(self, i):
        return 2 * i + 2

    def insert(self, val):
        """Вставка элемента в кучу"""
        self.heap.append(val)
        self.__heapify_up(len(self.heap) - 1)

    def __heapify_up(self, i):
        """Восстановление свойства кучи снизу вверх"""
        while i > 0 and self.heap[self.__parent(i)] < self.heap[i]:
            # Меняем местами, если родитель меньше текущего элемента
            self.heap[self.__parent(i)], self.heap[i] = (
                self.heap[i],
                self.heap[self.__parent(i)],
            )
            i = self.__parent(i)

    def extract_max(self):
        """Извлечение максимального элемента"""
        if not self.heap:
            return None

        max_val = self.heap[0]
        # Перемещаем последний элемент в корень
        self.heap[0] = self.heap.pop()
        # Восстанавливаем свойство кучи сверху вниз
        self.__heapify_down(len(self.heap), 0)
        return max_val

    def __heapify_down(self, length: int, i: int):
        """Восстановление свойства кучи сверху вниз"""
        left_child = self.__left_child(i)
        right_child = self.__right_child(i)

        largest = i  # Индекс наибольшего элемента

        # Сравниваем с левым потомком
        if left_child < length and self.heap[left_child] > self.heap[largest]:
            largest = left_child

        # Сравниваем с правым потомком
        if right_child < length and self.heap[right_child] > self.heap[largest]:
            largest = right_child

        # Если наибольший элемент не текущий, меняем местами и продолжаем
        if largest != i:
            self.heap[i], self.heap[largest] = self.heap[largest], self.heap[i]
            self.__heapify_down(length, largest)

```

### Big O кучи
| Операция         | Сложность  | Примечание                          |
|------------------|------------|-------------------------------------|
| `insert(val)`    | O(log n)   | Вставка + "подъем" элемента         |
| `extract_min()/ extract_max()`  | O(log n)   | Удаление + "спуск" элемента         |

Операции выполняются за O(log n), так как мы содержим кучу сбалансированной, а значит имеем минимальную высоту. А как мы помним по проблеме вырожденного дерева, операции на деревья пропорциональны высоте дерева. Аналогично и здесь

## Заключение
Бинарная куча представляет собой **оптимизированную древовидную структуру**, которая обеспечивает эффективный доступ к экстремальным элементам (минимуму или максимуму) и поддерживает оптимальную производительность ключевых операций.

- Корнем кучи является минимальный/максимальный элемент
- Бинарная куча бывают двух видов: min-heap и max-heap
- Операции кучи выполняются за O(log n)
- Куча является практически полностью сбалансированным деревом
- Кучу реализуют через бинарное дерево и массив.
- Используют для сортировки (max-heap) через heapsort, а также для реализации очереди с приоритетом (min-heap)














