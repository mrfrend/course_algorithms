## Что такое обход?
Под обходом подразумевается посещение каждой вершины (узла) дерева. И мы можем это сделать разными способами.

### Виды обходов
1. Обход в глубину. При таком подходе мы идем как можно глубже по ветви, затем возвращаемся и исследуем другие ветви. По порядку посещения выделяют:
	1. **In-order (симметричный)**. Посещаем сначала левую ветвь, затем корень, а после правую ветвь. **Позволяет вывести элементы в порядке возрастания**
	2. **Pre-order (прямой)**. Посещаем сначала корень дерева, затем левую ветвь, а затем правую ветвь. **Такой подход можно использовать для копирования существующего дерева**, ведь мы обходим элементы в порядке добавления.
	3. **Post-order (обратный)**. Посещаем левую ветвь, затем правую а уже затем корень. **Такой подход можно использовать для удаления дерева**.
2. Обход в ширину. При таком подходе мы проходим по каждому уровню последовательно.

### Подготовка
Создадим такое дерево из прошлого урока, используя нашу реализацию:

![Визуализация дерева](https://habrastorage.org/getpro/habr/upload_files/436/448/4ce/4364484ceb269c6a63717f31451a358c.png)

Я сделаю это за вас :)
```python
tree = BinarySearchTree()
tree.insert(8)
tree.insert(3)
tree.insert(10)
tree.insert(1)
tree.insert(6)
tree.insert(4)
tree.insert(7)
tree.insert(14)
tree.insert(13)
```

### In-order обход

Опять же, все реализуем для простоты через рекурсию. Каждая вершина по сути является корнем для соответствующего поддерева.

Стратегия перемещения In-order обход: Левый -> Корень -> Правый.

Что у нас за базовый случай? Это отсутствие узла, иными словами, `None`. Когда мы дошли до `None`, мы дошли до тупика. Дальше пути нет.

```python
def inorder_traversal(self):
	self.__inorder_recursive(self.root)

  
def __inorder_recursive(self, node):
	if node is not None:
		self._inorder_recursive(node.left)
		print(node.key)
		self._inorder_recursive(node.right)
```

Если узел у нас является `None`, то наша рекурсия не будет вызываться, и функция просто неявно вернет `None`.

### Pre-order обход и Post-order обход
На самом деле, pre-oder и post-order реализуются также. Меняется лишь порядок трех строк.

**Pre-order:** Корень -> левый -> правый:
```python

def preorder_traversal(self):
	self._preorder_recursive(self.root)

def _preorder_recursive(self, node):
	if node:
		print(node.key)
		self._preorder_recursive(node.left)
		self._preorder_recursive(node.right)

```

**Post-order:** Левый -> правый -> корень
```python
def postorder_traversal(self):
	self._postorder_recursive(self.root)

def _postorder_recursive(self, node):
	if node:
		self._postorder_recursive(node.left)
		self._postorder_recursive(node.right)
		print(node.key)
```

### Обход в ширину
При обходе в ширину нам необходимо работать с узлами **в порядке их поступления**.  Для этого будем использовать очередь, а на Python для этого используем готовую реализацию двухсторонней очереди `deque` из модуля `collections`.

Какой алгоритм?:
1. Создаем очередь. Добавляем туда корневой узел
2. Пока наша очередь не пуста
3. Выводим значение узла
4. Если есть левый потомок, то добавляем его в очередь
5. Если есть правый потомок, то добавляем его в очередь
6. Возвращаемся на шаг 2

Таким образом, мы будем по уровня дерева, и переходить на следующий только и только после обработки предыдущего уровня дерева.

```python
def bfs(self):
	queue = deque([self.root])
	while queue:
		node = queue.popleft()
		if not node:
			return
		
		print(node.key)

		if node.left:
			queue.append(node.left)

		if node.right:
			queue.append(node.right)
```

## Заключение
- Обход дерева может производиться как в ширину, так и в глубину
- При обходе в глубину идем до конца ветви, а затем рассматриваем другие
- При обходе в ширину мы просматриваем уровень, и только после этого переходим на следующий уровень дерева.
- In-order (симметричный) обход позволяет пройтись по дереву от меньшего узла к большему
- Pre-order (прямой) обход позволяет копировать структуру дерева
- Post-order обход позволяет удалить все дерево