**Дерево** - структура данных, хранящая узлы иерархически.

Дерево состоит из *вершин* (узлы) и *рёбер*
![Визуализация дерева](https://habrastorage.org/getpro/habr/upload_files/436/448/4ce/4364484ceb269c6a63717f31451a358c.png)

## Основные понятия дерева
1. **Вершина (узел)**. Это элемент, который хранит данные и *может иметь ссылки* на другие вершины (узлы). На изображении выше у нас есть вершина 6, вершина 8, вершина 1 и так далее.
2. **Ребро**. Это связь между вершинами. На картинке вершина 8 связана с вершиной 3.
3. **Корень.** Это самый верхний узел дерева, от которого начинаются все остальные вершины. В нашем примере корнем дерева является узел 8.
4. **Лист**. Это узел, не имеющий связи с другими узлами. По изображению выше листами являются узлы 1, 4, 7, 13.

## Отношения между узлами
1. **Родитель** - это узел, имеющий дочерние элементы. Узел 8 является родителем для узлов 3 и 10
2. **Дочерние узлы** -  узлы, которые связаны с родителем. Узел 3 является дочерним для узла 8
3. **Предки**. Родитель узла, прародитель, прапрародитель (и так далее вплоть до корневого узла) являются предками для конкретного узла. Узел 8 является предком узла 13
4. **Потомки**. Соответственно дочерний узел, внук, правнук. Узел 6 является потомком узла 8

## Высота дерева и уровень узла
У каждого узла есть *уровень* - это длина пути (количество рёбер) от него до корневого узла.

![Дерево и уровни узлов](https://i.pinimg.com/736x/9f/73/49/9f7349cdfccd3e4cf9da8f96c00a3555.jpg)

По изображению видно, что уровень узла C - 1, а узла O - 4.

У дерева также есть своя характеристика - *высота дерева*. Это уровень самого глубокого узла в дереве. В нашем случае высота дерева будет равняться четырём.

## Отличительные свойства дерева
1. Один корневой узел. 
2. Каждый узел (кроме корня) имеет только одного родителя
3. Отсутствие циклов. Под циклом подразумевается возможность вернуться к пройденной точки в пути.
	- К примеру, мы прошли до узла D через узлы A и B. Если же мы имеем возможность из узла D снова вернуться к узлам выше, то это цикл.

Если некоторые свойства не присутствуют, то вероятно перед вами *граф* - это общий случай дерева. Разрешены циклы, несколько родительских узлов. **Любое дерево — это граф, но не любой граф — дерево.**

## Виды деревьев
1. **Бинарное дерево (Binary Tree).** Это дерево, в котором вершина может иметь максимум два дочерних узла.
2. **Бинарное дерево поиска (Binary Search Tree).** В таких деревьях у нас может быть до двух дочерних узлов включительно, однако положения узлов определяется следующими правилами.
	- Узлы, которые меньше либо равны родители, располагаются в левой поддереве
	- Узлы, которые больше родителя, располагаются в правом поддереве
Первое изображение выше является примером бинарного дерева поиска. 
3. **Двоичная куча (Binary Heap).** Это особый тип бинарного дерева поиска, позволяющий нам получать ***мгновенно*** самый больший или же самый малый элемент в дереве. Это достигается организацией дерева таким образом, что самый большой/самый малый элемент дерева является его корнем.
 ![Двоичная куча](https://avatars.mds.yandex.net/get-entity_search/1879189/845743837/S600xU_2x)
 4. **Дерево общего вида**. Узлы могут иметь **любое количество потомков**.
 5. **Сбалансированные деревья**. Это деревья, решающие одну проблему бинарного дерева поиска.
 6. **B-дерево**. Это деревья, используемые в базах данных. Узлы могут хранить несколько элементов, а также иметь множество потомков.

## Где используют деревья?

Раз деревья - это про иерархию, то на ум приходит файловая система. Также деревья используют в DOM-дереве и абстрактном синтаксическом дереве - дерево, которое создают компиляторы перед генерацией машинного кода

Деревья также используют для индексов в базе данных (B-дерево).

### Что дальше?

Этот урок был посвящен базовой теории по деревьям. В модули будут рассмотрено в основном бинарные деревья поиска, двоичные кучи и сбалансированные деревья






